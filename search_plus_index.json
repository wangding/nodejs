{"./":{"url":"./","title":"简介","keywords":"","body":"Node.js 应用开发 本网站包含 Node.js 应用开发课程的全部教学资料，包括：课程大纲、学习交流 QQ 群、课程视频、幻灯片、通关任务以及示例代码。 课程大纲 Node.js 应用开发课程大纲 学习交流群 王顶老师的 QQ 学习交流群：301862163，加群时请报上自己的真实姓名，以及正在学习的课程内容。软件学院的学生不用加入此群，使用班级 QQ 群交流即可。 课程视频 每个视频其内容相对独立，时长较短，因此整个课程的视频数量比较多。把视频链接和课程大纲整合在一起，形成整门课程的视频清单方便大家按需观看。 通关任务 按课程讲授的顺序，排列在电子书左侧导航中，大部分通关任务对应有参考的示例代码，请见下面 nodejs-demo 仓库的链接。 示例代码 nodejs-demo，包含大部分 node.js 原生 API 的示例代码。 nodejs-advanced-demo，包含 Koa2 框架、JWT 和 ORM，等第三方 API 的示例代码。 entropy，计算信源熵的命令行工具示例代码，这个程序支持所有控制台交互方式。 cartoon-api，漫画书网站的 HTTP API 接口服务，这个示例代码是基于 Koa2 和 sequelize ORM 开发的，后台数据库用的是 MySQL。 todo-list-api，待办事项 HTTP API 接口服务的示例代码。 2018 -  by 王顶. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/README.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/README.html\"});gitalk.render(\"gitalk-container\"); "},"ch01-nodejs-introduction.html":{"url":"ch01-nodejs-introduction.html","title":"第一课：Node.js 简介","keywords":"","body":"第 1 课：Node.js 简介 阅读参考资料 Node.js 官方网站 Node.js 官方 API Node.js 中文 API 下载并浏览电子书 电子书网盘链接：http://pan.baidu.com/s/1nuU6C8h 密码: h6jc 搭建开发环境 方式一：导入虚拟机（推荐） 下载并安装 vmware workstation Pro 15+（已经安装 vmware workstation，跳过此步） 下载 mocha 虚拟机压缩文件 解压缩 mocha 虚拟机 用 vmware workstation，打开解压后的 mocha 虚拟机 启动 mocha 虚拟机 登录 mocha 虚拟机，用户名：wangding，密码：ddd 配置 mocha 虚拟机的网卡 IP 地址，具体操作请参考：教学视频 确保在 mocha 虚拟机中，ping www.baidu.com 可以正常执行 下载并安装 xshell 用 XShell 链接 mocha 虚拟机 方式二：从头安装 安装步骤请参考：Node.js 开发环境搭建 安装 CentOS 虚拟机，请参考：教学视频 配置开发环境 4.1 配置 git 参数 配置 git 的 user.name 和 user.email 参数，否则 git commit 不能正常工作 运行命令 git config --list，查看当前的 git 配置信息 如果没有配置 user.name 和 user.email 参数，请执行下面的操作 运行命令 git config --global user.email \"Your Email\"，配置 user.name 参数 运行命令 git config --global user.name \"Your Name\"，配置 user.email 参数 注意，上面两个命令需要把双引号中的文字改成具体的姓名和邮箱 运行命令 git config --list，查看刚配置的 git 参数 熟悉开发环境的使用 熟悉开发环境的使用 熟悉常用的 linux 命令用法 熟悉 Git 命令的用法 熟悉 vim 的用法 可以选择观看课程视频来熟悉开发环境 hello world 命令行程序 要求： 创建 nodejs-demo 目录 把 .tern-project 代码自动补全配置文件，放到 nodejs-demo 目录下，操作方法如下： 在 nodejs-demo 目录下，运行 wget http://sample.wangding.co/nodejs/tern-project 在 nodejs-demo 目录下，运行 mv tern-project .tern-project 创建 01-introduction 目录 编写 01-hello-world.js 在命令行打印 hello world! 字符 hello world web 服务程序 要求： 编写 02-hello-world-server.js 监听端口：8080 当收到 HTTP 请求时，发送响应文本 Hello world! 代码风格是 createSever 方法和 listen 方法的链式调用 用浏览器测试 web 程序 用 curl linux 命令行程序测试 web 程序 hello world web 服务程序 要求： 编写 03-hello-world-server.js 监听端口：8080 当收到 HTTP 请求时，发送响应文本 Hello world! 代码风格是首先调用 createSever 方法创建的服务对象 其次，监听服务对象的 request 事件 最后，调用服务对象的 listen 方法 用浏览器测试 web 程序 用 curl linux 命令行程序测试 web 程序 2018 -  by 王顶. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch01-nodejs-introduction.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch01-nodejs-introduction.html\"});gitalk.render(\"gitalk-container\"); "},"ch02-global-01.html":{"url":"ch02-global-01.html","title":"第二课：全局（上）","keywords":"","body":"第 2 课：全局（上） 全局变量 要求： 创建 02-global-var 目录 编写 01-file-dir-name.js 脚本 在控制台输出 __filename 和 __dirname 两个变量 完成项目目录下，'views' 子目录中，网页模板 'view.html' 的路径拼接 在控制台输出拼接后的路径信息 阅读 Node.js API 资料 console API 资料 控制台格式化输出信息 要求： 创建 03-console 目录 编写 01-format.js 脚本 定义一个 user 对象，包含三个字段：name, age, qq 使用三种占位符，分别输出三种变量类型：字符串，整数和 JSON 数据 以两种不用占位符的方式输出 user.qq 信息 向标准错误流中输出信息：Error：something wrong! 通过命令行重定向，观察 console.log 和 console.error 两个方法所使用流的区别./01-format.js > output.txt ./01-format.js 2> error-msg.txt 控制台基准测试 要求： 编写 02-time.js 脚本 对耗时任务运行的时间进行采样 在控制台输出采样的时间 多运行几次程序，观察同样的耗时任务每次采样的时间是否相同 阅读 Node.js API 资料 process API 资料 获取平台信息 要求： 创建 04-process 目录 编写 01-information.js 脚本 向控制台打印 CPU 架构信息以及操作系统版本信息 打印进程 id 信息以及 Node.js 可执行文件的绝对路径信息 在脚本中增加标准输入流的读取操作，让程序暂停执行 执行 Linux 命令 ps aux，验证当前进程的 ID 信息和程序中得到的进程 ID 信息相同 打印 Node.js 版本信息，当前登录用户 id 信息，当前登录用户所属组 id 信息以及当前脚本所在路径信息 在命令行执行 'node -v' 命令，验证程序输出的 node.js 版本信息是否正确 在命令行执行 'id' 命令，验证程序输出的登录账户 id 信息是否正确 在命令行执行 'pwd' 命令，验证程序输出的当前工作目录信息是否正确 打印内存使用情况 打印环境变量 在命令行执行 'env' 命令，验证程序输出的环境变量信息正确 获取命令行参数 要求： 编写 02-calc.js 脚本 获取命令行参数，命令行参数为一个数学表达式 如果没有命令行参数，打印程序的使用说明 如果命令行参数是 --help 或者 -h，打印程序的使用说明 如果命令行参数多于 3 个，多余的参数忽略 对命令行参数的表达式进行求值，打印求值结果 如果命令行参数不是合法的数学表达式（例如：a+b），则打印错误信息 命令行参数的格式如下： 操作标准输入输出流 要求： 编写 03-std-io.js 脚本 逐条打印提示信息：姓名、邮箱、QQ 号和手机号码 读取用户键盘输入信息，保存到对象中 用户键盘输入结束后，打印完整的对象信息 用户随时可以按 Ctrl + D，终止信息输入，打印对象信息，程序结束运行 处理退出码 要求： 编写 04-exit-code.js 脚本 通过命令行参数获取程序的退出码，以该退出码退出程序 通过 echo $? 命令查看程序的退出码 对命令行参数的退出码，做数据合法性校验，如果命令行参数不正确，控制台打印准确的错误提示信息 处理信号量 要求： 编写 05-signal.js 脚本 接收信号量，并对信号（SIGINT 和 SIGTSTP）进行处理 用控制台快捷键，给程序脚本发送信号量，测试程序的功能逻辑 CTRL+C 发送 SIGINT 信号量，让程序退出 CTRL+Z 发送 SIGTSTP 信号量，让程序挂起 用 kill 命令，给程序脚本发送信号量，测试程序的功能逻辑 实现 my-kill 程序 要求： 编写 06-my-kill.js 脚本 获取命令行参数，得到进程 ID 信息和信号量标识符 对命令行参数有数据合法性校验，数据非法时，在控制台打印准确的错误提示信息 向指定进程 ID 的进程发送特定的信号量 用 06-my-kill.js 脚本，向 05-signal.js 脚本发送信号量，测试两个程序的功能逻辑 阅读 Node.js API 资料 阅读 global API 资料 中的六个定时器函数相关的资料 定时炸弹 要求： 创建 05-timer 目录 编写 01-bomb.js 脚本 编写定时炸弹构造函数 炸弹的 start 方法启动定时器，3 秒钟之后炸弹爆炸 炸弹的 clear 方法取消定时器 实例化两个定时炸弹对象：b1 和 b2 b1 调用 start 方法 b2 调用 start 方法 b2 在 1 秒钟之后，调用 clear 方法 运行程序，测试程序的执行效果 定时器 要求： 编写 02-timer.js 脚本 创建两个定时器：timer1 和 timer2 两个定时器都是 500 ms 触发一次定时任务 timer1 启动后，倒计时 5s 结束 timer1 并启动 timer2 timer2 定时任务执行 5 次后退出 运行程序，测试程序执行的效果 sleep 要求： 编写 03-sleep.js 脚本 用 Promise 实例封装 sleep 方法，可以让程序暂停执行若干毫秒 运行程序，测试程序执行的效果 使用 node.js v15 引入的 Promise 版本的 setTimeout 实现 sleep 2018 -  by 王顶. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch02-global-01.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch02-global-01.html\"});gitalk.render(\"gitalk-container\"); "},"ch03-global-02.html":{"url":"ch03-global-02.html","title":"第三课：全局（下）","keywords":"","body":"第 3 课：全局（下） 阅读 Node.js API 资料 Buffer API 资料 Buffer 基本操作 要求： 创建 06-buffer 目录 编写 01-basic.js 脚本 实例化一个 buffer 对象 buf1，缓冲区的大小是 256 字节，初始化第一个字节为零，控制台打印 buf1 的长度和内容 通过循环初始化 buf1 的每个字节，每个字节比上个字节大 1，控制台打印 buf1 的内容 对 buf1 做切片操作，取出后 10 个字节，存放到 buf2 中，控制台打印 buf2 的内容和长度 对 buf2 做填充操作，所有字节填充为零，控制台打印 buf2 的内容 用数组（数组内容随意）初始化 buf3，控制台打印 buf3 中的内容和长度 用字符串（字符串内容随意）初始化 buf4，控制台打印 buf4 中的内容和长度，打印 buf4 字符串 将 buf4 的内容复制到 buf3 中，打印复制后的 buf3 内容和长度，打印 buf3 字符串 Buffer 编码 要求： 编写 02-encode.js 脚本 阅读 basic authentication 资料 从命令行参数获取登录网站的用户名和密码信息 命令行参数的格式：cmd user_name password 命令行参数不正确时，提示用户命令行参数的正确格式 在控制台打印用户名和密码信息 将用户名和密码信息拼接成一个字符串，用冒号（:）分割 将拼接后的字符串转化成 base64 编码，并打印在控制台上 Buffer 解码 编写 03-decode.js 脚本 从命令行参数获取用户名和密码信息的 base64 编码字符串 命令行参数的格式：cmd base64_string 命令行参数不正确时，提示用户命令行参数的正确格式 将 base64 编码的字符串转换成 utf8 编码的字符串 将还原后的用户名和密码信息打印在控制台上 还原信息不正确时，请提示错误信息 Buffer 实现 Data URI 要求： 编写 04-data-uri.js 脚本 阅读 data URI scheme 资料 执行 wget http://sample.wangding.co/nodejs/nodejs-logo.bmp 下载 nodejs-logo.bmp 测试图片 执行 wget http://sample.wangding.co/nodejs/qr-code.jpg 下载 qr-code.jpg 测试图片 执行 wget http://sample.wangding.co/nodejs/book.png 下载 book.png 测试图片 从命令行参数获取图片文件名 命令行参数的格式：cmd file_name 命令行参数不正确时，提示用户命令行参数的正确格式 命令行参数的图片文件不存在时，提示错误信息 把图片数据生成 data URI 格式的数据 把 data URI 数据打印到控制台 把 data URI 数据嵌入到 HTML 页面中 创建一个 HTTP 服务，监听 8080 端口 浏览器请求 HTTP 服务的 URL 地址时，得到嵌入图片数据的 HTML 页面 提示： 文件操作需要导入 fs 模块： const fs = require('fs'); 读取文件数据可以使用 readFileSync 方法：var data = fs.readFileSync(fileName); 同步读取文件时，如果文件不存在会抛出异常，可以使用 try-catch 捕获异常 获取文件扩展名，需要导入 path 模块：const path = require('path'); 获取文件扩展名使用 path 模块的 extName 方法：var ext = path.extName(fileName); Buffer 读取位图信息 要求： 编写 05-bmp-info.js 脚本 阅读 BMP 文件格式资料 从命令行参数获取图片文件名 命令行参数的格式：cmd file_name 命令行参数不正确时，提示用户命令行参数的正确格式 命令行参数的图片文件不存在时，提示错误信息 获取图片的宽度、高度和颜色深度三个信息，并打印在控制台上 Buffer 写位图文件 要求： 编写 06-bmp-write.js 脚本 从命令行参数获取图片文件名 命令行参数的格式：cmd file_name 命令行参数不正确时，提示用户命令行参数的正确格式 写一个 16 * 16 像素，颜色深度为 32 位的位图文件 位图的所有像素为红色 阅读 Node.js API 资料 module API 资料 使用第三方模块 要求： 创建 07-module 目录 编写 01-chalk.js 脚本 阅读 chalk 模块文档 导入 chalk 模块 调用 chalk 模块的颜色方法，在控制台打印带颜色的信息 安装 chalk 模块，运行程序 创建 package.json 文件，用 npm install -S chalk 安装模块 查看 package.json 文件中的依赖项 创建自定义模块，导出变量 要求： 编写 02-export-var.js 脚本 导出变量 Math.PI 打印 module 信息 编写 02-main.js 脚本 导入 02-export-var.js 打印导入模块的变量，打印的文字用绿色 打印 module 信息 运行 02-main.js，观察程序的输出 创建自定义模块，导出函数 要求： 编写 03-export-function.js 脚本 定义 circle 工厂函数 函数的入口参数是圆的半径 circle 函数返回一个对象 对象中有两个成员函数，分别计算圆的面积和周长 导出 circle 函数 打印 module 信息 编写 03-main.js 脚本 导入 03-export-function.js 调用 circle 的面积和周长方法，并打印结果，打印的文字为绿色 打印 module 信息 运行 03-main.js，观察程序的输出 创建自定义模块，导出对象 v1 要求： 编写 04-export-object.js 脚本 定义 Circle 类 Circle 类有三个公开 getter 属性方法，分别是圆的直径、面积和周长 Circle 构造函数接收一个参数：圆的半径 导出 Circle 类 打印 module 信息 编写 04-main.js 脚本 导入 04-export-object.js 调用 circle 的直径、面积和周长方法，并打印结果，打印的文字为绿色 打印 module 信息 运行 04-main.js，观察程序的输出 创建自定义模块，导出对象 v2 要求： 编写 05-export-object.js 脚本 定义 circle 对象字面量 circle 对象有三个公开方法，分别计算圆的直径、面积和周长 导出 circle 对象 打印 module 信息 编写 05-main.js 脚本 导入 05-export-object.js 调用 circle 的直径、面积和周长方法，并打印结果，打印的结果为绿色 打印 module 信息 运行 05-main.js，观察程序的输出 创建自定义模块，导出对象 v3 要求： 编写 06-export-object.js 脚本 在 module.exports 对象上添加三个属性，分别是直径、周长和面积 给三个属性分别赋值为函数，计算圆的直径、面积和周长 打印 module 信息 编写 06-main.js 脚本 导入 06-export-object.js 调用 circle 的直径、面积和周长方法，并打印结果，打印的结果为绿色 打印 module 信息 运行 06-main.js，观察程序的输出 思考上面四个任务代码的作用、编写方式，等差异 使用模块级变量在对象间共享信息 要求： 编写 07-share.js 脚本 定义模块级变量 count 定义构造函数 Num Num 有两个公开方法：add 让 count 加一，getCount 得到 count 的值 导出构造函数 Num 编写 07-main.js 脚本 导入 07-share.js 脚本定义的 Num 构造函数 用 Num 实例化 n1 和 n2 两个对象 n1.add() 方法调用两次 控制台打印 n1.getCount() 和 n2.getCount() n2.add() 方法调用一次 控制台打印 n1.getCount() 和 n2.getCount() 运行 07-main.js 程序，观察程序运行结果，理解程序工作原理 管理一组相关模块 要求： 创建 08-circle 文件夹 目录结构如下08-circle ├── bin │ └── circle ├── index.js ├── lib │ ├── area.js │ ├── circumference.js │ └── diameter.js └── package.json 编写 lib/area.js 脚本，导出计算圆面积的函数 编写 lib/diameter.js 脚本，导出计算圆直径的函数 编写 lib/circumference.js 脚本，导出计算圆周长的函数 编写 index.js 脚本，导出对象 circle，具有三个方法分别计算圆的直径、周长和面积 这三个方法是从上面定义的三个脚本文件导入而来 编写 bin/circle 脚本，导入 index.js 中的 circle 对象 调用 circle 的直径、面积和周长方法，并打印结果 运行 bin/circle，观察程序的输出 cd ~/nodejs-demo/ && cp -r 07-module/08-circle node_modules/circle 运行上面的命令，把 08-circle 目录，复制到 node_modules 文件下，并改名为 circle 编写 08-main.js 脚本 导入 circle 对象，调用 circle 的三个方法 在 node.js 中使用 ES6 模块机制 要求： 编写 09-es6-module.js 脚本 用 ES6 的 import 关键字引入 node.js 内置模块：http 用 ES6 的 import 关键字引入 chalk 第三方模块 创建类似 hello-world-server 的 web app 监听 8080 端口 另外，在收到 http 请求时，在控制台用亮绿色 (chalk.greenBright) 打印 HTTP 请求起始行 请求起始行，例如：GET / HTTP/1.1，包括三部分： 请求方法(req.method) 请求路径(req.url) HTTP 版本(req.httpVersion) 运行 09-es6-module.js 脚本，用 curl 或浏览器测试该 web app 要求： 复制 04-export-object.js 为 09-export-object.js 修改代码，用 ES6 的 export 关键字导出 Circle 类 编写 09-main.js 脚本，import 导入 09-export-object.js 的 Circle 类 根据命令行参数的 radius 数据，控制台输出圆的周长和面积信息 例如：$ ./09-main.js 8 circle area: 201.06192982974676 circle circumference: 50.26548245743669 2018 -  by 王顶. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch03-global-02.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch03-global-02.html\"});gitalk.render(\"gitalk-container\"); "},"ch04-event.html":{"url":"ch04-event.html","title":"第四课：事件","keywords":"","body":"第 4 课：事件 阅读 Node.js API 资料 EventEmitter API 资料 使用 EventEmitter 类（可选） 要求： 创建 08-event 目录 编写 01-event-emitter.js 脚本 实例化 EventEmitter 对象 每隔 1 秒 EventEmitter 对象发出自定义 hello 事件 延迟 5 秒 EventEmitter 对象发出自定义 bye 事件 hello 事件处理函数在控制台打印 hello world 信息 bye 事件处理函数在控制台打印 goodbye 信息，并结束程序 继承 EventEmitter 类 要求： 编写 02-dog.js 以及 02-play-dog.js 脚本 02-dog.js 脚本实现 Dog 类，并导出 Dog 类 Dog 类继承 EventEmitter 类 Dog 类中，包含：name 和 energy 两个私有数据成员 name 是狗的名字，energy 是狗的能量 用构造函数对私有数据 name 和 energy 进行初始化 energy 大于零时，每隔 1 秒发出 bark 狗叫事件 狗每叫一次，energy 减 1，energy 为零时，狗不能叫 Dog 的 energy 可以被修改 02-play-dog.js 中导入 Dog 类 实例化多个 Dog 的对象，不同的 Dog 对象有不同的名字和能量 不同的狗采用同一个 bark 事件处理函数 bark 事件处理函数在控制台打印狗的名字以及它的能量 util.inherits 方法继承 EventEmitter 类（可选） 要求： 编写 03-radio.js 以及 03-listen-radio.js 脚本 radio 类用 util 的 inherits 方法继承 EventEmitter 类 radio 类的构造函数有一个入口参数 station 对象 station 对象包括两个字段：freq 和 name radio 类延迟 0 秒发出 play 事件 radio 类延迟 5 秒发出 stop 事件 play 和 stop 事件携带事件参数 station 对象 03-listen-radio.js 脚本，实例化 radio 对象 处理 radio 对象的 play 和 stop 事件 play 和 stop 事件处理函数打印 station 电台信息以及状态 复制 EventEmitter 类成员（可选） 要求： 复制 03-radio.js 和 03-listen-radio.js 脚本 编写 04-radio.js 和 04-listen-radio.js 脚本 不使用 util.inherits 方法继承 EventEmitter 类 将 EventEmitter 类中方法复制到 radio 类中 测试程序 自己实现事件机制 要求： 复制 02-dog.js 和 02-play-dog.js 脚本 编写 05-dog.js 和 05-play-dog.js 脚本 不使用 EventEmitter 类，编写 05-event.js 脚本，自己实现 Event 类 Dog 类继承自己实现的 Event 类 测试程序的运行 自己实现事件机制（可选） 要求： 复制 03-radio.js 和 03-listen-radio.js 脚本 编写 06-radio.js 和 06-listen-radio.js 脚本 不使用 EventEmitter 类，Radio 类继承 05-event.js 脚本中的 Event 类 测试程序的运行 生产者和消费者 要求： 编写 07-prd-csm.js 脚本 生产者：Producer，create 方法把新数据放到队列 queue 中 消费者：Consumer，destory 方法把队列 queue 中的数据取出 队列：Queue，用数组实现。在队列末尾放入新数据，数组长度加一。在队列头部取出数据，数组长度减一。 在已有代码基础上完成功能要求，不能修改 main 函数，其他的代码可以根据需要添加和修改。 要求生产数据，和消费数据并发执行。即，生产一个数据，消费一个数据。具体功能参考下面的代码和运行效果 部分代码： class Queue { constructor() {} write(data) {} read() {} } class Producer { constructor() {} create(data){ log('+ prd create:', data); queue.write(data); } } class Consumer { constructor() {} destroy(){ log('- csm destroy:', queue.read()); } } function main() { const prd = new Producer(); for(let i=0; i 运行效果如下： + prd create: 0 - csm destroy: 0 + prd create: 1 - csm destroy: 1 + prd create: 2 - csm destroy: 2 + prd create: 3 - csm destroy: 3 + prd create: 4 - csm destroy: 4 2018 -  by 王顶. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch04-event.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch04-event.html\"});gitalk.render(\"gitalk-container\"); "},"ch05-stream.html":{"url":"ch05-stream.html","title":"第五课：流","keywords":"","body":"第 5 课：流 阅读参考资料 Node.js 流 API 资料 海纳百川：Node.js Stream 深入理解 Node.js Stream 内部机制 Node.js 流: 你需要知道的一切 操作标准输入/输出流 要求： 创建 09-stream 目录 编写 01-std-io.js 脚本 通过 data 事件消费标准输入流中的数据 将标准输入流的字符转成大写，然后输出到标准输出流中 在标准输入流中 push 一些字符串 通过 pipe 方法将标准输入流接到标准输出流上，消费标准输入流中的数据 用 for 循环在标准输出流上输出 a-z 26 个字母 用交互式的方式运行程序 用流的方式运行程序（命令如下），观察程序运行的结果 cat 01-std-io.js | ./01-std-io.js 思考两种程序运行方式的差异以及背后的原理 Web 静态文件服务 要求： 编写 02-static-web-server.js 脚本 web 服务器根路径是当面脚本所在目录 web 服务监听 8080 端口 正确响应浏览器发送的 URL 请求 将 URL 地址中的文件内容，发送给浏览器 当 URL 地址中的资源文件不存在时，提示用户文件不存在的错误信息 基于流的 Web 静态文件服务 要求： 编写 03-static-web-server-stream.js 脚本 用流的方式实现任务 3 的所有功能 编写 03-make-big-file.js 脚本 运行 03-make-big-file.js 脚本生成 427M 的 big.file 运行 02-static-web-server.js 脚本，用 curl 请求 big.file，观察服务器内存消耗 运行 03-static-web-server-stream.js 脚本，用 curl 请求 big.file，观察服务器内存消耗 理解流的优势 可读推送流 要求： 编写 04-readable-push.js 脚本 实例化 Readable 流 向流中 push 若干个字符串 将 Readable 流管道连接到标准输出流 运行程序，观察程序的运行效果 可读拉取流 要求： 编写 05-readable-pull.js 脚本 实例化 Readable 流 实现流的 _read 方法 _read 方法中循环 push [a-z] 26 个字母 将流接入到标准输出流 运行程序，观察程序的运行效果 自定义可读流 要求： 编写 06-my-readable.js 脚本 定义 MyReadable 类继承 Readable 类 MyReadable 类的功能跟任务 6 类似 实例化 MyReadable 类 将 MyReadable 类的实例化对象接入到标准输出流上 运行程序，观察程序的运行效果 自定义可写流 要求： 编写 07-green-stream.js 脚本 定义 GreenStream 类继承 Writable 类 GreenStream 类将收到的数据输出到标准输出流中 使用 chalk，将输出的文本信息格式化成亮绿色 实例化 GreenStream 类，将标准输入流连接到自己定义的可写流对象上 运行程序，观察程序的运行效果 用转换流实现字母大写转换 要求： 编写 08-transform.js 脚本 实例化 Transform 流对象 Transform 流对象中实现字符串的大写转换 将标准输入流管道接到转换流对象上再接到标准输出流上 用两种方式运行程序，观察程序的运行效果 自定义转换流实现文字变色 要求： 编写 09-my-transform.js 脚本 定义自己的转换流类继承 Transform 类 自己的转换流类实现控制台文字加颜色，参考：任务 8 实例化自己的转换流对象 将标准输入流管道接到自己的转换流对象再接入到标准输出流上 用两种方式运行程序，观察程序的运行效果 2018 -  by 王顶. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch05-stream.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch05-stream.html\"});gitalk.render(\"gitalk-container\"); "},"ch06-file-system.html":{"url":"ch06-file-system.html","title":"第六课：文件系统","keywords":"","body":"第 6 课：文件系统 阅读 Node.js API 资料 文件 API 资料 将 fs 模块中的函数分类整理成思维导图 回调异步方式打印文件内容 要求： 创建 10-file-system 目录 编写 01-my-cat-async.js 脚本 要求支持命令行参数，包括：要打印的文件名 没有命令行参数时，默认打印脚本本身内容 文件不存在则打印错误信息 文件存在则在控制台打印文件内容 用回调异步方式读取文件内容 Promise 异步方式打印文件内容 要求： 创建 10-file-system 目录 编写 02-my-cat-promise.js 脚本 要求支持命令行参数，包括：要打印的文件名 文件不存在则打印错误信息 文件存在则在控制台打印文件内容 用 Promise 异步方式读取文件内容 底层 API 打印文件内容 要求： 编写 03-my-cat-lower.js 脚本 要求支持命令行参数，包括：要打印的文件名 没有命令行参数时，默认打印脚本本身内容 文件不存在则打印错误信息 文件存在则在控制台打印文件内容 用底层 API 打开文件，再同步读取文件内容 混合方式打印文件内容 要求： 编写 04-my-cat-mix.js 脚本 要求支持命令行参数，包括：要打印的文件名 没有命令行参数时，默认打印脚本本身内容 文件不存在则打印错误信息 文件存在则在控制台打印文件内容 用底层 API 打开文件，再同步读取文件内容 用 writeSync 向控制台输出文件内容 流方式打印文件内容 要求： 编写 05-my-cat-stream.js 脚本 要求支持命令行参数，包括：要打印的文件名 没有命令行参数时，默认打印脚本本身内容 文件不存在则打印错误信息 命令行参数是目录名称时打印相应的错误信息 文件存在则在控制台打印文件内容 用流的方式读取文件内容并将管道接入到标准输出流上 同步方式打印文件内容 要求： 编写 06-my-cat-sync.js 脚本 要求支持命令行参数，包括：要打印的文件名 没有命令行参数时，默认打印脚本本身内容 文件不存在则打印错误信息 文件存在则在控制台打印文件内容 用同步的方式读取文件内容并将文件内容输出到控制台上 复制文件 要求： 编写 07-my-cp.js 脚本 要求支持命令行参数，包括：要复制的源文件名和目标文件名 源文件不存在则打印错误信息 除了能复制文件内容，还需要复制文件权限 用 fs 模块的底层 API 实现 07-my-cp-low.js 用 fs 模块的同步 API 实现 07-my-cp-sync.js 用 fs 模块的异步 API 实现 07-my-cp-async.js 用 fs 模块的底层和高级 API 实现 07-my-cp-mix.js 用 fs 模块的流 API 实现 07-my-cp-stream.js 移动文件 要求： 编写 08-my-mv.js 脚本 要求支持命令行参数，包括：要移动的源文件名和目标文件名 源文件不存在则打印错误信息 除了能移动文件，可以修改文件名 删除文件 要求： 编写 09-my-rm.js 脚本 要求支持命令行参数，包括：要删除的文件名 文件不存在打印错误信息 文件存在则删除 如果命令行参数指定的是一个目录，则忽略他 创建空文件 要求： 编写 10-my-touch.js 脚本 要求支持命令行参数，包括：要创建的文件名 命令行参数不存在打印错误信息 创建指定名称的文件 文件的长度为 0 字节 查看目录内容 要求： 编写 11-my-ls.js 脚本 要求支持命令行参数，包括：要查看的目录名 命令行参数不存在的情况下，默认查看当前脚本所在目录 命令行参数指定的目录不存在的情况下，打印错误信息 在控制台打印指定目录下的内容 创建目录 要求： 编写 12-my-mkdir.js 脚本 要求支持命令行参数，包括：要创建的目录名 命令行参数不存在的情况下，打印错误信息 在当前目录创建指定名称的文件夹 删除目录 要求： 编写 13-my-rm-dir.js 脚本 要求支持命令行参数，包括：要删除的目录名 命令行参数不存在的情况下，打印错误信息 删除指定名称的文件夹 如果命令行参数是一个文件名，则忽略他 创建链接 要求： 编写 14-my-ln.js 脚本 要求支持命令行参数，包括：源文件和链接文件或者 -s 选项 -s 选项说明创建的是符号链接 没有 -s 选项说明创建的是硬链接 命令行参数不正确时，提示相应的错误信息 可以创建硬链接也可以创建符号链接 打印链接 要求： 编写 15-read-lnk.js 脚本 要求支持命令行参数，包括：链接文件名 命令行参数不存在的情况下，打印错误信息 命令行参数指定的文件名不存在时，打印错误信息 正常情况下打印符号链接所链接的文件 修改文件权限 要求： 编写 16-my-chmod.js 脚本 要求支持命令行参数，包括：权限模式和文件名 命令行参数不存在的情况下，打印错误信息 命令行参数指定的文件名不存在时或者其他参数不正确时，打印相应的错误信息 正常情况下修改指定文件的权限 修改文件所有者 要求： 编写 17-my-chown.js 脚本 要求支持命令行参数，包括：用户 ID，组 ID 和文件名 命令行参数不存在的情况下，打印错误信息 命令行参数指定的文件名不存在时或者其他参数不正确时，打印相应的错误信息 正常情况下修改指定文件的所属用户和所属组 文件信息统计 要求： 编写 18-my-stat.js 脚本 要求支持命令行参数，包括：要统计信息的文件名 命令行参数不存在的情况下，默认统计当前脚本文件的信息 命令行参数指定的文件名不存在时，打印错误信息 正常情况下统计命令行参数指定文件的统计信息 监视文件变化 要求： 编写 19-watch.js 脚本 监视脚本所在目录下文件的变化 把目录下文件的变化输出到控制台 按下 Ctrl+C 或者 kill -2 pid，程序结束运行 程序结束前打印程序将要结束运行的提示信息 程序并不立即结束，需要等 5 秒后才结束 递归删除 要求： 编写 20-my-rm.js 脚本 要求支持命令行参数，包括：要删除的目录名或文件名 命令行参数不存在的情况下，打印错误信息 命令行参数指定的文件名或者目录名不存在时，打印错误信息 如果命令行参数是合法的文件名，则删除文件 如果命令行参数是合法的目录名，则删除该目录以及该目录下的所有文件以及子目录 2018 -  by 王顶. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch06-file-system.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch06-file-system.html\"});gitalk.render(\"gitalk-container\"); "},"ch07-debug.html":{"url":"ch07-debug.html","title":"第七课：调试","keywords":"","body":"第 7 课：调试 静态代码检查 要求： 浏览 ESLint 官网 在 nodejs-demo 目录下初始化 ESLint 配置文件 如果不希望 ESLint 检查某些文件夹或文件，则配置 .eslintignore 文件 用 ESLint 工具检查自己写过的所有代码 如果规则定义合理，则改正代码中问题 如果规则定义的不合理，则修改规则设置 打印调试 要求： 创建 11-debug 目录 复制 09-stream/02-static-web-server.js 到 11-debug 目录下 修改文件名为 01-static-web-server.js 修改代码，添加打印调试或者屏蔽打印调试 运行程序，观察打印调试信息是否正常显示 修改代码，支持对 NODE_DEBUG 环境变量的打印调试支持 运行程序，观察打印调试信息是否正常显示 添加 NODE_DEBUG 环境变量 运行程序，观察打印调试信息是否正常显示 Node.js 命令行调试器 要求： 使用 Node.js 命令行调试器，调试 server.js 程序，去掉程序中的 bug 获取 server.js 程序，运行：wget http://sample.wangding.co/nodejs/server.js Chrome 图形界面调试器 要求： 使用 Chrome 图形界面调试器，调试 server.js 程序，去掉程序中的 bug 性能分析 要求： 使用 Node.js 性能分析工具，分析 profile.js 程序 获取 profile.js 程序，运行：wget http://sample.wangding.co/nodejs/profile.js 2018 -  by 王顶. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch07-debug.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch07-debug.html\"});gitalk.render(\"gitalk-container\"); "},"ch08-child-process.html":{"url":"ch08-child-process.html","title":"第八课：子进程","keywords":"","body":"第 8 课：子进程 阅读 API 资料 子进程 API 资料 execFile 方式调用外部程序 要求： 创建 12-child-process 目录 编写 01-exec-file.js 脚本 可以执行任何一个外部程序 命令行参数中有需要执行的外部程序以及外部程序的参数 如果没有命令行参数，执行 cat 命令，打印 01-exec-file.js 脚本文件内容 外部程序运行的正确信息打印在控制台上 外部程序运行的错误信息打印在控制台上 测试用例 1：执行 ./01-exec-file.js，预期结果：控制台打印 01-exec-file.js 文件内容 测试用例 2：执行 ./01-exec-file.js mkdir abc，预期结果：当前目录下创建 abc 文件夹 测试用例 3：执行 ./01-exec-file.js mkdir abc, 预期结果：报错，abc 文件夹已存在 测试用例 4：执行 ./01-exec-file.js ls -l / /usr /var，预期结果：长格式输出根目录、/usr 和 /var 三个目录的内容 测试用例 5：执行 ./01-exec-file.js abc，预期结果：报错，Error: spawn abc ENOENT spawn 方式调用外部程序 要求： 编写 02-spawn-v1.js 脚本 打印当前进程 ID 信息 执行一个外部命令，例如：cat 打印 02-spawn-v1.js 脚本文件内容 自定义的外部程序 要求： 编写 03-child.js 脚本 打印当前进程 ID 信息 每 2 秒在控制台打印当前时间 16 秒后程序结束运行 execFile 调用自定义的外部程序 要求： 编写 04-exec-file.js 脚本 打印当前进程 ID 信息 调用 03-child.js 外部程序 观察程序的运行结果 spawn 调用自定义的外部程序 要求： 编写 05-spawn-v2.js 脚本 打印当前进程 ID 信息 调用 03-child.js 外部程序 观察程序的运行结果 比较与 04-exec-file.js 程序运行结果的差异 体会 execFile 和 spawn 方法的区别 HTTP 服务调用自定义的外部程序 要求： 编写 06-spawn-v3.js 脚本 创建 HTTP 服务 监听 8080 端口 接收到客户端请求后，执行 03-child.js 外部程序 将任务 4 程序的运行结果，输出到 HTTP 客户端 用 curl 客户端请求服务程序，观察程序运行的结果 管道方式连接多个外部程序 要求： 编写 07-spawn-v4.js 脚本 创建一个 data.txt 文本文件，内容如下：wangding louying wangchenxin wangding 用 spawn 方法通过管道执行：cat，sort，uniq 三个外部程序 相当于执行命令：cat name.txt | sort | uniq 最终得到有序的、除掉重复内容的信息 spawn 进程分离 要求： 编写 08-detach.js 脚本 打印主进程 ID 信息 用 spawn 方法调用 03-child.js 外部程序 外部程序和主进程分离 主进程 5 秒后退出 子进程运行的结果输出到标准输出流中 观察主进程退出后，子进程是否还在运行 exec 方式调用外部程序 要求： 编写 09-exec.js 脚本 支持命令行参数 命令行参数描述要只执行的外部程序 执行命令行参数中描述的外部程序 将外部程序的运行结果打印到控制台 fork 方法调用外部程序 要求： 编写 10-fork.js 脚本 打印当前进程 ID 信息 用 fork 方法调用 03-child.js 外部程序 主进程 5 秒后退出 观察主进程退出后，子进程是否还在运行 进程间通信之子进程 要求： 编写 11-ipc-child.js 脚本 打印当前进程 ID 信息 接收到父进程发送的消息后，将消息内容打印到控制台 向父进程发送消息 进程间通信之父进程 要求： 编写 12-ipc-father.js 脚本 打印当前进程 ID 信息 用 fork 方法调用 11-ipc-child.js 程序 2 秒后向外部程序发送进程间消息 6 秒后父进程退出执行，并通知子进程结束执行 子进程收到结束信号 5 秒后，子进程退出执行 同步调用外部程序 要求： 编写 13-sync.js 脚本 打印父进程 ID 信息 用 spawn 的同步版本调用 03-child.js 外部程序 观察同步调用外部程序的运行结果和异步调用的区别 2018 -  by 王顶. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch08-child-process.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch08-child-process.html\"});gitalk.render(\"gitalk-container\"); "},"ch09-network.html":{"url":"ch09-network.html","title":"第九课：网络","keywords":"","body":"第 9 课：网络 阅读 Node.js API 资料 net API 资料 TCP 服务端程序 要求： 创建 13-tcp 目录 编写 01-server.js 脚本 接收客户端的字符数据 收到 ls 时，将当前目录的文件名以及子目录名发送到客户端 收到 quit 时，服务程序退出运行 监听 8080 端口 用 telnet 测试本程序 TCP 客户端程序 要求： 编写 02-my-telnet.js 脚本 支持命令行参数 第一个命令行参数是需要连接的远程服务器 IP 地址 第二个命令行参数是需要连接的远程服务器端口号 接收键盘输入字符 将接收到的键盘数据发送到远程服务器上 将远程服务器的响应数据打印到控制台上 连接到 HTTP 服务器上做测试，测试服务器地址：http://sample.wangding.co/web/one-div.html 连接到 FTP 服务器上做测试，测试服务器地址：ftp://ftp.gnu.org 阅读 Node.js API 资料 dgram API 资料 UDP 服务端程序 要求： 创建 14-udp 目录 编写 01-server.js 脚本 监听 8080 端口 收到客户端消息后，将客户端消息打印到控制台 用 nc 测试 UDP 服务端程序 UDP 客户端程序 要求： 编写 02-my-nc.js 脚本 支持命令行参数 第一个命令行参数是需要连接的远程服务器 IP 地址 第二个命令行参数是需要连接的远程服务器端口号 接收键盘输入字符 将接收到的键盘数据发送到远程服务器上 阅读 Node.js API 资料 dns API 资料 域名解析 要求： 创建 15-dns 目录 编写 01-dns.js 脚本 支持命令行参数 命令行参数是需要解析的域名 将域名解析的结果 IP 地址打印到控制台 2018 -  by 王顶. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch09-network.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch09-network.html\"});gitalk.render(\"gitalk-container\"); "},"ch10-http-client.html":{"url":"ch10-http-client.html","title":"第十课：HTTP 客户端","keywords":"","body":"第 10 课：HTTP 网络编程（客户端） 阅读 Node.js API 资料 http API 资料 了解 HTTP 协议 要求： HTTP 协议相关的知识主要包括： HTTP 命令，包括：GET、POST，等 HTTP 报文，包括：请求报文头，请求报文体、响应报文头和响应报文体 HTTP 响应状态码 阅读 HTTP 协议资料 阅读 HTTP 头部字段资料 阅读 HTTP 状态码资料 用 telnet 工具了解 HTTP 协议的相关知识 用 curl 工具了解 HTTP 协议的相关知识 用 chrome 开发者工具了解 HTTP 协议的相关知识 用上面三个工具访问 http://sample.wangding.co/web/one-div.html ，查看请求和响应的头信息，如下图所示： 搞明白请求头部字段列表中每个字段的含义和作用 搞明白响应头部字段列表中每个字段的含义和作用 GET 请求网站页面 要求： 创建 16-http-client 目录 编写 01-my-curl.js 脚本 获取命令行参数：要请求的 URL 地址 向该 URL 地址发出 GET 请求 将 HTTP 响应的起始行、响应头和响应体内容打印到控制台 定义 user-agent 为 01-my-curl 用 http 模块的 get 方法实现 运行并测试程序 GET 请求 HTTP API 要求： 编写 02-get-repos.js 脚本 获取某个账户的所有公开 Gitee 仓库的数量和名称 账户信息通过命令行参数获取 API 参考：https://gitee.com/api/v5/swagger#/getV5UsersUsernameRepos 运行并测试程序 运行效果如下图所示： POST 发送数据 要求： 编写 03-post.js 脚本 向指定的 URL 地址发出 HTTP POST 请求 POST 请求中携带向服务器程序发送的特定数据 向服务器程序发送的数据通过命令行参数获取 将服务器程序的响应起始行、响应头和响应体内容打印到控制台 编写 03-server.js 脚本 接收 03-post.js 脚本发送的 POST 请求数据 将接收到的请求起始行、请求头和请求体数据打印到控制台 运行并测试程序 简单爬虫程序 要求： 编写 04-crawler.js 脚本 爬取动漫屋网站的漫画书封面图片 需爬取的网页地址：https://tel.dm5.com/manhua-list/ 提示： 用 chrome 打开网址：https://tel.dm5.com/manhua-list/ 打开 chrome 开发者工具，切换到 network 选项卡 在网页上点击【题材】-> 【热血】，观察 chorme 开发者工具的 network 选项卡下的 HTTP 请求 观察第一个请求 dm5.ashx?t=xxxx，这个请求是一个 AJAX 请求，返回数据是 JSON 返回的 JSON 数据中，有漫画书的封面 URL 地址 可以把这个 JSON 数据保存为一个 json 文件，根据这个 json 文件，来爬取漫画书的封面图片 这个 JSON 数据相当于爬虫的任务链接列表 复杂爬虫程序 要求： 编写 05-crawler.js 脚本 npm i -S cheerio 安装项目依赖 cheerio 用 cheerio 对爬取的 HTML 页面进行 DOM 元素解析 cheerio 用法请参考：cheerio API 爬取 segmentfault 网站的免费课程信息 需爬取的网页地址：https://ke.segmentfault.com/free 从爬取的网页中解析出课程信息，包括：课程名称，课程地址 将爬取的课程信息格式化输出到控制台 HTTP 重定向（略） 要求： 编写 06-redirection.js 脚本 实现对 HTTP 协议的重定向状态的处理 测试 URL：http://www.sian.com/ 需要获取重定向后的最终页面 将最终页面输出到控制台 2018 -  by 王顶. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch10-http-client.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch10-http-client.html\"});gitalk.render(\"gitalk-container\"); "},"ch10-http-server.html":{"url":"ch10-http-server.html","title":"第十课：HTTP 服务端","keywords":"","body":"第 10 课：HTTP 网络编程（服务端） 阅读 Node.js API 资料 url API 资料 解析 HTTP 方法 要求： 创建文件夹 17-http-server 编写脚本代码 01-method-parse.js 使用 http 模块创建 web 服务监听 8080 端口 解析 HTTP 请求的方法 使用 switch case 语句 至少解析 GET、POST、PUT 和 DELETE 四个 HTTP 方法 需要在 web 服务器程序中打印 HTTP 请求的方法名称 需要给客户端反馈信息 用 curl -X 参数测试各种 HTTP 请求方法 解析 URL 要求： 编写脚本代码 02-url-parse.js 解析给定的 url 地址：http://wangding:123@www.baidu.com:8080/a/b/c?age=20&gender=M#/d/e/f 在控制台打印解析的结果 使用 http 模块，创建 web 服务监听 8080 端口 对 HTTP 请求的 URL 地址进行解析 在控制台打印解析的结果 用 curl http://localhost:8080/a/b/c?age=20&gender=M#/d/e/f 命令测试上面的服务程序 思考为什么没有解析出 hash: #/d/e/f 解析 HTTP 请求头 要求： 编写脚本代码 03-req-header-parse.js 使用 http 模块创建 web 服务监听 8080 端口 在控制台打印完整的 HTTP 请求起始行和请求头信息 在控制台打印 HTTP 请求头信息中的 User-Agent、Host 和 Content-Type 三个字段信息 在 curl 程序中向 web 服务发送特定的头部字段信息 Content-Type:appliction/json，测试服务程序 curl -H \"Content-Type:appliction/json\" http://localhost:8080 解析 HTTP 协议的基本身份验证请求头字段：authorization，将用户名和密码信息打印在控制台 用命令 curl http://wangding:123@localhost:8080 测试服务程序 处理 HTTP 响应 要求： 编写脚本代码 04-response.js 使用 http 模块创建 web 服务监听 8080 端口 当客户端请求网站根路径（/）时，发送给客户端一个 h1 格式的 hello world! 网页 并且发送响应状态码 200 并且发送响应头字段列表：Content-Type: text/html 以及 Content-Length: XXX Content-Length 中的三个 X 表示响应体的实际字节数 当客户端请求网站其他路径时，发送状态码 404，以及 Resource not found！信息 用 curl 程序测试这个 web 服务的不同 URL，查看响应起始行、响应报文头以及响应体 处理上传数据 要求： 编写脚本代码 05-upload.js 使用 http 模块创建 web 服务监听 8080 端口 请求的 URL 不是网站根路径（/）时，提示客户端 404 错误 如果 HTTP 请求的方法不是 POST 时，提示客户端 404 错误 接收客户端 HTTP POST 请求中携带的数据 将收到的数据打印到控制台上 用 curl 程序测试服务程序，包括以下一些场景 用 curl 向服务程序发送 FORM 表单数据 用 curl 向服务程序发送 JSON 数据 用 curl 向服务程序上传文件 处理 GET 请求的 FORM 表单 要求： 编写脚本代码 06-form-get.js 使用 http 模块创建 web 服务监听 8080 端口 当 HTTP 请求的 URL 不是网站根路径（/）时，提示客户端 404 错误 向客户端发送一个 TODO list 表单页面，页面上用户可以填写待办事项 用户点击提交按钮后，表单使用 HTTP 的 GET 方法提交到服务程序 服务程序接收表单数据，并将待办事项放到 TODO list 表单页面，发送给客户端 用 chrome 浏览器测试服务程序 用 curl 测试服务程序 TODO list 表单页面样式如下： 处理 POST 请求的 FORM 表单 要求： 编写脚本代码 07-form-post.js 使用 http 模块创建 web 服务监听 8080 端口 当 HTTP 请求的 URL 不是网站根路径（/）时，提示客户端 404 错误 当收到客户端 HTTP GET 请求时，发送给客户端 TODO list 表单页面 页面上用户可以填写待办事项，用户提交表单使用 POST 方法 用 chrome 浏览器测试服务程序 用 curl 测试服务程序 TODO list 页面样式见上面截图 网页 Linux 命令行 要求： 基于 07-form-post.js 代码 编写 08-form-cmd.js 脚本 用户在表单页面上提交 linux 命令 服务程序利用子进程技术执行 linux 命令 服务程序将 linux 命令的运行结果返回到网页上 命令运行结果要求能够正确的换行显示 程序的运行效果，如下图所示： 处理文件上传 要求： 编写 09-upload-file.js 脚本 能够接收任意格式文件上传 将上传的文件保存在脚本所在目录 保存在服务器上的文件名和上传的文件名相同 用 crul 命令测试脚本 编写文件上传的 HTML 页面 用浏览器访问上传文件的 HTML 页面，实现文件上传 改进程序，让程序能够同时支持多个文件上传 上传图片 要求： 在 09-upload-file.js 脚本的基础上 编写 10-upload-pic.js 脚本 能够接收任意格式图片文件（png, jpg, gif, bmp）上传 将上传的图片文件保存在脚本所在目录的 images 子目录下 保存在服务器上的图片文件名和上传的文件名相同 页面上能够显示已经上传的所有图片 运行并测试程序 后台模板渲染 要求： 编写 11-form-html.js 脚本 对 07-form-post.js 重构 将 07-form-post.js 脚本中的 HTML 代码，保存在单独的文件中 template.html 将 template.html 中的待办事项数据部分用占位符 % 来代替 11-form-html.js 程序读取 template.html 模板文件 并将占位符 % 替换为具体的待办事项数据 用 chrome 测试服务程序 前后端分离架构的代办事项 实现 RESTful API 要求： 阅读理解 RESTful 架构 阅读 RESTful API 设计指南 编写 12-rest-api.js 脚本 使用任务 2 方法解析的框架代码 服务程序要响应 GET、POST、PUT 和 DELETE 四种请求方法 实现对待办事项的增、删、改、查，HTTP 接口规格如下：method: GET, url: /todo, fun: get all todo items method: POST, url: /todo, fun: insert todo item method: DELETE, url: /todo, fun: del all todo items method: DELETE, url: /todo:id, fun: del todo item by id method: PUT, url: /todo:id, fun: update todo item by id 用 curl 测试 RESTful API 客户端请求 url 为网站根路径时，服务程序发送代办事项页面给客户端 所以，服务程序不是纯粹的 HTTP 接口服务 实现前端页面 代办事项页面使用前端脚本，fetch 请求 HTTP 接口 并将获取的待办事项 JSON 数据展示到页面上 阅读 fetch 官方文档 阅读 fetch 用法说明 编写客户端代码使用 RESTful API 在页面上实现查询和增加代办事项的功能 在页面上实现删除和修改代办事项的功能 用 chrome 测试 web 服务程序 程序的运行效果，如下图所示： 2018 -  by 王顶. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch10-http-server.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch10-http-server.html\"});gitalk.render(\"gitalk-container\"); "},"ch11-http-advanced.html":{"url":"ch11-http-advanced.html","title":"第十一课：HTTP 进阶","keywords":"","body":"第 11 课：HTTP 高级编程 实现 HTTP 基本验证 要求： 创建 18-http-advanced 目录 编写 01-auth-basic.js 脚本 实现 web 服务程序 当浏览器对根路由（/）发出 HTTP 请求时，脚本不需要身份验证，发送给客户端非敏感信息 当浏览器对后台管理路由（admin）发出 HTTP 请求时，脚本需要身份验证 身份验证基于 HTTP 协议的基本验证 当收到用户名和密码信息之后，验证身份信息 如果身份信息正确，发送给客户端敏感信息 如果身份信息不合法，则继续提示用户输入身份信息 Cookie 基本操作 要求： 编写 02-cookie-opt.js 脚本 使用 http 模块创建 web 服务监听 8080 端口 解析请求头中的 Cookie 数据，将解析的 Cookie 信息打印到控制台上 在响应头中封装 Cookie 数据，将响应数据发送给客户端 用 chrome 浏览器测试服务程序，在开发者工具中查看和修改 cookie 信息 用 curl 工具测试服务程序，命令：curl -H \"Cookie: name=wangding\" http://localhost:8080 Cookie 状态保持 要求： 编写 03-cookie-status.js 脚本 使用 http 模块创建 web 服务监听 8080 端口 客户端程序每次请求服务程序时，对总请求的次数计数，打印到控制台 将客户端请求的次数信息保存到客户端的 Cookie 中 将请求的次数信息发送给客户端 用不同的浏览器测试服务程序 请思考： 为什么不同的浏览器上请求的次数不同？ 为什么不同的浏览器上请求的次数不是服务器接收到请求的总和？ 为什么 chrome 浏览器每次刷新，请求的次数加 2？如何改为加 1？ 为什么服务程序重启后，客户端再次请求服务程序，客户端的请求次数没有清零？ 人为修改客户端 Cookie 信息，再次请求服务程序，看看收到的反馈信息 Cookie 辅助登录 要求： 编写 04-cookie-auth.js 脚本 使用 http 模块创建 web 服务监听 8080 端口 在客户端的 Cookie 中保存登录的状态信息 如果客户端的 Cookie 没有信息或者登录的状态是未登录 客户端访问服务程序时，得到是登录页面 登录页面提交 POST 表单数据，包括：用户名和密码信息 服务程序验证收到的 POST 表单中的用户名和密码信息 如果账户信息没有验证通过，则服务程序继续发送客户端登录页面 如果账户信息验证通过，则服务程序设置客户端 Cookie 的登录状态信息为已经登录 如果客户端的 Cookie 中的登录状态是已经登录 客户端访问服务程序时，得到的是网站首页，而不是登录页面 在网站首页，用户可以点击退出登录链接 服务程序会设置客户端 Cookie 的登录状态信息为未登录 服务程序会发送客户端登录页面 用浏览器测试服务程序 人为修改浏览器的 Cookie 信息，是否能伪装成已经登录，得到网站的首页 实现 Session 要求： 编写 05-session.js 脚本 使用 http 模块创建 web 服务监听 8080 端口 在客户端的 Cookie 中保存 SessionID 信息 在服务程序中实现对客户端 Cookie 中 SessionID 的解析 在服务程序中用内存维护一个 Session 列表 服务程序能够创建 Session，包括 SessionID 和过期时间 服务程序能够检查客户端 Cookie 中的 SessionID 是否存在，或者 Session 是否过期 对于过期的客户端 Session 服务器会重新分配 SessionID，并将过期的 Session 从列表中删除 对于没有过期的客户端 Session 服务器会更新该 Session 的过期日期 Session 辅助登录 要求： 在前两个任务的基础上编写 06-session-auth.js 脚本 使用 SessionID 作为登录状态的验证 Cookie 中 SessionID 如果不存在，打开登录页面 Cookie 中 SessionID 过期，打开登录页面，重新登录 Cookie 中 SessionID 存在，并且没有过期，打开首页，并且更新 Session 的过期时间 用浏览器测试服务程序 看看人为修改浏览器的 Cookie 信息，是否能伪装成已经登录，得到网站的首页 TODO List 要求： 利用上一个任务 Session 辅助验证的技术改造 TODO List 实现 TODO List 身份验证 实现不同登录用户的 TODO List 操作 实现 HTTP 代理 要求： 编写 07-proxy.js 脚本 实现对 HTTP 协议的 GET 请求的代理 在代理程序中捕获浏览器的 HTTP 请求信息，输出到控制台 将 HTTP 响应信息输出到控制台 配置 chrome 浏览器的代理设置 测试代理程序 阅读 Node.js API 资料 https API 资料 实现 HTTPS 服务 要求： 编写 08-https-server.js 脚本 实现 HTTPS 协议的 Web 服务 收到浏览器请求后，发送给客户端 hello world 信息 2018 -  by 王顶. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch11-http-advanced.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch11-http-advanced.html\"});gitalk.render(\"gitalk-container\"); "},"ch12-data-storage.html":{"url":"ch12-data-storage.html","title":"第十二课：数据存储","keywords":"","body":"第 13 课：数据存储 Web 静态文件服务 要求： 创建目录 18-data-storage 复制 09-stream/02-static-web-server.js 到当前目录 修改文件名为 01-static-web-server.js 实现内存缓存机制，提升 web 服务器的性能 如果请求的 url 中的文件不在内存缓存中 读取磁盘上的文件，存入缓存 将缓存中的文件内容发送给浏览器 如果请求的 url 中的文件在内存缓存中 直接将缓存中的文件内容发送给浏览器 基于文件存储 RESTful API 要求： 复制 16-http-server/08-rest-api.js 到当前目录 修改文件名为 02-rest-api.js 修改 02-rest-api.js 脚本 服务程序退出时将待办事项数组保存到当前目录的 data.txt 中 服务程序启动时将待办事项从 data.txt 中读取到 items 数组中 安装 MySQL 要求： 确保当前的 Linux 虚拟机上 MySQL 环境 执行命令：mysql --version，检查 MySQL 客户端是否安装 执行命令：systemctl status mysqld，检查 MySQL 服务程序是否运行 如果上面两个命令的运行结果正常，请跳过下面的安装过程 在 CentOS 7 Linux 上安装 MySQL 运行安装命令 # 下载并安装 MySQL 官方的 Yum Repository wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm # yum 安装 mysql sudo yum -y install mysql57-community-release-el7-10.noarch.rpm # 安装 mysql 服务程序，这个步骤时间可能会比较长，取决于个人网速 sudo yum -y install mysql-community-server # 启动数据库服务 sudo systemctl start mysqld.service # 查看 MySQL 运行状态 sudo systemctl status mysqld.service # 找到 mysql 初始的 root 用户密码 sudo grep \"password\" /var/log/mysqld.log # 进入数据库 Shell 环境，修改 root 账户密码 # 注意，密码有复杂度要求，要记住改后的密码 mysql -u root -p ALTER USER 'root'@'localhost' IDENTIFIED BY 'iqjLryKLu9%C'; # 在数据库 Shell 环境中，测试 root 账户的权限 show databases; create database abc; show databases; exit; 命令行操作 MySQL 要求： Linux 命令行连接 MySQL 在 test 数据库中，创建 areas 表+-----------+--------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +-----------+--------------+------+-----+---------+----------------+ | id | int(11) | NO | PRI | NULL | auto_increment | | area_name | varchar(255) | NO | UNI | NULL | | +-----------+--------------+------+-----+---------+----------------+ 在 areas 表上练习 CURD 操作 阅读 mysql2 API 资料 mysql2 API 资料 用 Node.js 对 MySQL 做 CURD 操作 要求： 编写 03-mysql.js 脚本 安装 mysql2 第三方库 连接到 test 数据库，做以下操作 在 areas 表中插入一条记录 查询 areas 表中的记录 在 areas 表中更改刚才插入的记录 查询 areas 表中的记录 在 areas 表中删除刚才修改的记录 查询 areas 表中的记录 关闭连接 基于 MySQL 存储的 Todo List 要求： 创建 04-todo-list 子目录 复制 16-http-server/05-form-post 代码到 04-todo-list 目录下，改名为 index.js 在 04-todo-list 子目录 npm 初始化项目配置文件 package.json npm 安装 mysql2 模块，作为开发依赖项写入项目配置文件 创建 models 子目录 models 目录下，编写 config.json 文件，配置 mysql 数据库连接参数 models 目录下，编写 database.js 脚本，创建 mysql 数据库连接池 models 目录下，编写 todo-list.js 脚本，定义 TodoList 类 TodoList 类的 getAll 方法获取 todo 表中的所有记录 TodoList 类的 addItem 方法向 todo 表中添加一条待办事项 命令行连接 mysql 数据库，创建 todo_list 数据库以及 todo 表 用 chrome 或 curl 测试服务程序 2018 -  by 王顶. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch12-data-storage.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch12-data-storage.html\"});gitalk.render(\"gitalk-container\"); "},"ch13-express.html":{"url":"ch13-express.html","title":"第十三课：Express 框架","keywords":"","body":"第 12 课：Express 框架 阅读 Express API 资料 Express 4.x API ejs 编写 hello world web 程序 要求： 创建目录 18-express 创建子目录 01-hello-world 进入子目录 01-hello-world npm init 初始化项目 npm i express -S 安装 Express 模块 编写 index.js 脚本 实现一个 web 服务，监听 8080 端口 当浏览器请求网站根路径（/）时，返回客户端 hello world 响应 用 curl 或者 chrome 浏览器测试这个 web 服务 Web 静态文件服务 要求： 创建目录 02-static-web-server 进入 02-static-web-server 子目录 npm 命令初始化项目 npm 命令安装 Express 模块 编写 index.js 脚本 web 服务器根路径是当面脚本所在目录 web 服务监听 8080 端口 浏览器请求的 URL 合法时，返回给浏览器合适的文件资源 当 URL 地址中的资源文件不存在时，提示用户文件不存在的错误信息 用 curl 或者 chrome 浏览器测试这个 web 服务 了解 Express 框架代码 要求： 切换到 linux 的 root 账户 npm i -g express-generator 全局安装 express 代码生成器 切换到 linux 的开发者账户 express --version 查看 express 代码生成器的版本，验证安装是否成功 express -h 了解 express 代码生成器的命令行参数 express -e 03-quick-start 创建一个初始网站框架 cd 03-quick-start && npm install 安装项目依赖 DEBUG=03-quick-start:* npm start 启动网站 用 chrome 或 curl 测试这个网站，注意：这个网站默认监听 3000 端口 测试网站的时候，url 地址上的端口号一定要写成 3000，而不是 8080 tree -I node_modules 查看项目目录结构 搞明白每个目录的作用 搞明白每个代码文件的作用 阅读并理解框架代码的结构 如何让服务程序运行在 8080 端口 尝试修改框架代码，用浏览器测试网站，观察修改后的效果 基本路由 要求： 创建子目录 04-basic-router 进入子目录 04-basic-router npm 命令初始化项目 npm 命令安装 express 模块 编写 index.js 脚本 用 express 模块创建 web 服务，监听 8080 端口 脚本里处理五个路由：/、/json、/download、/courses/:id、/posts/:year/:month 五个路由的 HTTP 方法都是 GET /courses/:id 和 /posts/:year/:month 都是参数路由 将路由中的参数信息打印到控制台，并发送给客户端 ok 消息 /json 路由，发送给客户端一个自定义对象 /download 路由，发送给客户端 package.json 文件 / 路由，绑定四个处理函数（中间件） 其中两个处理函数，单独用 function 关键字定义 另外两个处理函数，在 get 方法的参数中作为匿名函数出现 用 chrome 或 curl 测试服务程序 任务 6: 路由模块 要求： 创建子目录 05-router-module 进入子目录 05-router-module npm 命令初始化项目 npm 命令安装 express 模块 编写 index.js 脚本 HTTP GET 方法请求网站根的基本路由，给客户端返回 hello world 编写 books.js 路由模块脚本，放到 router 子目录下 index.js 脚本 require 引入路由模块 express 应用将 books.js 路由模块挂载到 /books 路径的 GET 方法下 books 路由模块中，使用中间件打印调试信息 Date.now() books 路由模块中，处理 books/ 路由，返回客户端 books 字符串 books 路由模块中，处理 books/list 路由，返回客户端 books-list 字符串 用 chrome 或 curl 测试服务程序 Express 版 TODO List 要求： 用 express 代码生成器生成框架代码 06-todo-list 删除主程序 app.js 对 Cookie 机制的支持 删除主程序 app.js 对静态文件服务的支持 删除 public 目录 删除 users.js 路由文件 删除主程序 app.js 中对 users 路由模块的挂载和调用 修改 index.js 路由模块，支持 GET 和 POST 两个方法 GET 方法渲染 TODO List 页面，并传递 items 数组给模板 POST 方法将请求体中表单数据放入 items 数组中，并渲染页面 修改 index.ejs 模板页面，在页面中显示 H1 标题 TODO List H1 标题下方式表单区域，包括一个文本框，一个 submit 按钮 表单下方就是 TODO List 的 ul 列表 用 chrome 或 curl 测试服务程序 Express 版 TODO List API 要求： 用 express 代码生成器生成框架代码 07-todo-list-api 删除主程序 app.js 对 Cookie 机制的支持 删除主程序 app.js 对静态文件服务的支持 删除 public 目录 删除主程序 app.js 中对视图模板的支持 删除 views 目录 修改主程序 app.js 中错误处理对视图模板的调用 删除 users.js 路由文件 删除主程序 app.js 中对 users 路由模块的挂载和调用 修改 index.js 路由模块，支持对 TODO List 的增、删、改、查 用 curl 测试服务程序 Express 版 cookie-opt 要求： 创建子目录 08-cookie-opt 进入子目录 08-cookie-opt npm 命令初始化项目 npm 命令安装 express 和 cookie-parser 模块 编写 index.js 脚本 引用 cookie-parser 模块 实现根路由解析模块 打印请求中的 cookie 信息 在响应中设置 name = wangding 和 age = 41 两个 cookie 信息 发送客户端 ok 响应信息 用 chrome 测试服务程序 Express 版 cookie-status 要求： 用 express 代码生成器生成框架代码 09-cookie-status 删除 routes/users.js 路由模块 修改 app.js 删除 user.js 路由模块的引用和挂载 修改 routes/index.js 路由模块 从请求中获取 cookie 中存放的访问次数信息 将访问次数信息传递给模板页面 在模板页面上显示用户访问次数的信息 用 chrome 测试服务程序 Express 版 cookie-auth 要求： 用 express 代码生成器生成框架代码 10-cookie-auth 删除 routes/users.js 路由模块 修改 app.js 删除 user.js 路由模块的引用和挂载 修改 index.ejs 模块代码，显示登录后的状态信息以及退出登录的链接 添加 login.ejs 模板代码，显示登录对话框表单 修改 routes/index.js 代码，实现登录验证逻辑 实现 cookie 中保存登录状态的功能 实现退出登录请求，修改 cookie 登录状态的功能 用 chrome 测试服务程序 签名 Cookie 要求： 创建子目录 11-signed-cookie 进入子目录 11-signed-cookie npm 命令初始化项目 npm 命令安装 express 和 cookie-parser 模块 复制 08-cookie-opt/index.js 代码到当前目录 修改 index.js 脚本 实现对 cookie 数据 name = wangding 和 age = 41 进行签名加密 用 chrome 测试服务程序 Express session 辅助验证 要求： 用 express 代码生成器生成框架代码 12-session-auth 进入子目录 12-session-auth 修改 package.json 删除 cookie-parser 组件依赖 修改 app.js 代码，删除 cookie-parser 组件的导入和挂载 npm 命令安装项目依赖 npm 命令安装 express-session 组件 在 views 目录下添加 login.ejs 做一个登录页面 在 views 目录下修改 index.ejs 显示当前登录用户的欢迎界面，以及退出登录的链接 删除 routes 目录下的 users.js 修改 app.js 删除 routes/users.js 路由模块的导入和挂载 修改 routes 目录下的 index.js 路由模块，实现登录验证流程 登录验证流程参考 HTTP 进阶下的任务五 用 chrome 测试服务程序 2018 -  by 王顶. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch13-express.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch13-express.html\"});gitalk.render(\"gitalk-container\"); "},"ch14-project.html":{"url":"ch14-project.html","title":"第十四课：综合案例","keywords":"","body":"第 16 课：综合案例 信源熵计算 要求： 创建 entropy 仓库 编写命令行脚本程序，完成信源熵的计算 信源熵的计算公式：H(p) = -p1*log(p1, 2) - p2*log(p2, 2) - ... - pn*log(pn, 2) p1, p2, ..., pn 都是概率，其中，0 要求支持命令行参数输入概率 命令行参数输入概率要支持两种形式：逗号分隔和空格分隔 命令行参数输入形式不能混合，即：同时用逗号和空格分隔，视为错误输入 无命令行参数或者命令行参数不正确时，可以交互输入概率 要求对输入概率进行数据合法性验证 数据非法时，要有明确的错误提示信息 对程序中的通用模块进行封装 对程序中的通用模块用 Mocha 做单元测试，用 Istanbul 做代码覆盖率测试 命令行程序的交互效果，请参考下面的屏幕截图： 待办事项 待办事项 web 应用的服务器端，应用形态：HTTP API。 用户接口 登录验证 功能描述：提供登录信息，由服务端验证身份是否合法。如果合法，发放后续访问的令牌。否则，给出错误提示。 接口地址：POST /users/login 请求参数： 字段 类型 是否必填 说明 备注 email string 是 password string 是 返回数据： 字段 类型 说明 备注 code number 状态码 零为正常，非零代表错误 msg string 状态信息 错误描述 count number 记录条数 此字段无用 data string 具体数据 如果身份验证成功，这个数据是后续访问的令牌 注册账户 功能描述：注册账户。 接口地址：POST /users/signup 请求参数： 字段 类型 是否必填 说明 备注 email string 是 password string 是 返回数据： 字段 类型 说明 备注 code number 状态码 零为正常，非零代表错误 msg string 状态信息 错误描述 count number 记录条数 此字段无用 data string 具体数据 此字段无用 待办事项接口 获取待办事项 功能描述：获取登录当前登录用户的所有待办事项。 接口地址：GET /tasks/ 请求参数： 字段 类型 是否必填 说明 备注 token string 是 身份验证的令牌 token 在 HTTP 请求头中 返回数据： 字段 类型 说明 备注 code number 状态码 零为正常，非零代表错误 msg string 状态信息 错误描述 count number 记录条数 data string 待办事项数组 添加待办事项 功能描述：添加待办事项。 接口地址：POST /tasks/ 请求参数： 字段 类型 是否必填 说明 备注 token string 是 身份验证的令牌 token 在 HTTP 请求头中 content string 是 待办事项内容 可以是空字符串 folder_id number 否 待办事项所属文件夹 id 可以为 null 返回数据： 字段 类型 说明 备注 code number 状态码 零为正常，非零代表错误 msg string 状态信息 错误描述 count number 记录条数 此字段无用 data string 具体数据 此字段无用 修改待办事项 功能描述：修改待办事项的内容或者所属的文件夹或者删除状态，一次操作只能修改三者之一。 接口地址：PUT /tasks/:id 请求参数： 字段 类型 是否必填 说明 备注 token string 是 身份验证的令牌 token 在 HTTP 请求头中 id number 是 待修改待办事项的 id content string 否 新的待办事项内容 可以是空字符串 folder_id number 否 待办事项所属文件夹 id folder_id 为零，则待办事项不属于任何文件夹 recycle boolean 否 是否回收待办事项 回收待办事项会取消待办事项的删除状态 返回数据： 字段 类型 说明 备注 code number 状态码 零为正常，非零代表错误 msg string 状态信息 错误描述 count number 记录条数 此字段无用 data string 具体数据 此字段无用 删除待办事项 功能描述：删除待办事项。支持两种删除模式：硬删除（永久删除）和软删除。一次操作只删除一个待办事项，不支持批量删除。 接口地址：DELETE /tasks/:id?permanent=true|false 请求参数： 字段 类型 是否必填 说明 备注 token string 是 身份验证的令牌 token 在 HTTP 请求头中 id number 是 待删除待办事项的 id permanent boolean 是 是否永久删除 permanent = true，永久删除一条待办事项permanent = false，并不真正删除待办事项，而是设置该待办事项的 deletedTime 字段 返回数据： 字段 类型 说明 备注 code number 状态码 零为正常，非零代表错误 msg string 状态信息 错误描述 count number 记录条数 此字段无用 data string 具体数据 此字段无用 文件夹接口 获取文件夹 功能描述：获取登录当前登录用户的所有文件夹。 接口地址：GET /folders/ 请求参数： 字段 类型 是否必填 说明 备注 token string 是 身份验证的令牌 token 在 HTTP 请求头中 返回数据： 字段 类型 说明 备注 code number 状态码 零为正常，非零代表错误 msg string 状态信息 错误描述 count number 记录条数 data string 文件夹数组 添加文件夹 功能描述：添加文件夹。 接口地址：POST /folders/ 请求参数： 字段 类型 是否必填 说明 备注 token string 是 身份验证的令牌 token 在 HTTP 请求头中 item string 是 文件夹名称 不可以是空字符串 返回数据： 字段 类型 说明 备注 code number 状态码 零为正常，非零代表错误 msg string 状态信息 错误描述 count number 记录条数 此字段无用 data string 具体数据 此字段无用 修改文件夹 功能描述：修改文件夹的名称。 接口地址：PUT /folders/:id 请求参数： 字段 类型 是否必填 说明 备注 token string 是 身份验证的令牌 token 在 HTTP 请求头中 id number 是 待修改文件夹的 id item string 是 新的文件夹名称 不可以是空字符串 返回数据： 字段 类型 说明 备注 code number 状态码 零为正常，非零代表错误 msg string 状态信息 错误描述 count number 记录条数 此字段无用 data string 具体数据 此字段无用 删除文件夹 功能描述：删除文件夹，真正删除文件夹，但是不级联删除此文件夹下的待办事项。此文件夹下的所有待办事项的 folder_id 置为 null。 接口地址：DELETE /folders/:id 请求参数： 字段 类型 是否必填 说明 备注 token string 是 身份验证的令牌 token 在 HTTP 请求头中 id number 是 待删除文件夹的 id 返回数据： 字段 类型 说明 备注 code number 状态码 零为正常，非零代表错误 msg string 状态信息 错误描述 count number 记录条数 此字段无用 data string 具体数据 此字段无用 2018 -  by 王顶. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch14-project.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/ch14-project.html\"});gitalk.render(\"gitalk-container\"); "},"setup-dev-env.html":{"url":"setup-dev-env.html","title":"搭建 Node.js 开发环境","keywords":"","body":"搭建 Node.js 开发环境 本文档基于 Linux CentOS 7 发行版，搭建基于命令行的 Node.js 开发环境。下面的安装步骤，如果没有特殊说明，一定不要在 root 账户下操作。 下载软件包 在 Win10 操作系统下载下列软件包： 从腾讯软件中心下载 VMWare Worksation Pro 最新版 从腾讯软件中心下载 XShell 最新版 从 CentOS 官网下载 CentOS 安装镜像包 安装软件包 在 Win10 操作系统安装下列软件包： 安装 VMWare Workstation 安装 XShell 安装 Linux 虚拟机 创建空白虚拟机 运行 vmware workstation pro 软件，创建一个空白虚拟机，操作如下： vmware 软件窗口中点击“创建新的虚拟机”按钮 出现新建虚拟机向导对话框 您希望选择什么类型的配置，选择“自定义（高级）”，点击“下一步”按钮 虚拟机硬件兼容性配置，使用默认设置，点击“下一步”按钮 安装来源，选择“稍后安装操作系统”来创建一个空白的虚拟机，点击“下一步”按钮 客户端操作系统，选择“Linux”，版本，选择“CentOS 64位”，点击“下一步”按钮 虚拟机名称和位置，使用默认设置或者自己定义，点击“下一步”按钮 处理器配置，使用默认设置：1 个 CPU 1 个内核，点击“下一步”按钮 内存配置，使用默认设置：1024 M（1G 内存），点击“下一步”按钮 网络连接配置，使用默认设置：使用网络地址转换（NAT），点击“下一步”按钮 I/O 控制器类型，使用默认设置：LSI Logic（推荐），点击“下一步”按钮 选择磁盘，使用默认设置：创建新虚拟磁盘，点击“下一步”按钮 指定磁盘容量，使用默认设置：20 G，并选择“将虚拟磁盘存储为单个文件”，点击“下一步”按钮 磁盘文件名称：使用默认设置，点击“下一步”按钮 已经准备好虚拟机，点击“完成”按钮 设置虚拟机硬件 在刚创建的空白虚拟机上，需要进一步编辑虚拟机设置，操作如下： 移除声卡硬件 移除 USB 控制器硬件 移除打印机硬件 CD/DVD 使用 ISO 镜像文件：点击“浏览”按钮，找到下载的 CentOS ISO 镜像文件 指定显示器设置，配置监视器器的分辨率为：1024 X 768 最后，点击“确定”按钮，完成虚拟机硬件设置 安装操作系统 点击“开启虚拟机”绿色三角按钮，虚拟机窗口出现电脑自检画面，安装向导界面中，进行如下操作设置： 【有待完善】 第一个安装画面：选择安装 CentOS 7 语言：中文 安全策略：Common Profile for General-Purpose Systems 软件选择： 安装介质 安装位置 网络启用 root 密码 创建新用户并设置密码，把新用户加到管理员组中 设置虚拟机 IP 地址 【有待完善】 通过 XShell 连接 Linux 虚拟机 【有待完善】 此后的所有安装步骤都是在 Linux 虚拟机中进行操作。 安装 vim 9 # 卸载低版本的 vim sudo yum remove vim -y vim --version # 安装工具软件和依赖库 sudo yum install -y ruby ruby-devel lua lua-devel luajit wget unzip \\ luajit-devel ctags git python python-devel \\ python3 python3-devel tcl-devel ncurses-devel\\ perl perl-devel perl-ExtUtils-ParseXS \\ perl-ExtUtils-XSpp perl-ExtUtils-CBuilder \\ perl-ExtUtils-Embed gcc lrzsz ncurses-devel # 切换到家目录 cd # 创建 GitHub 仓库根目录 mkdir repos cd repos # 下载 vim 源代码 wget https://github.com/vim/vim/archive/master.zip # 解压缩源代码 unzip master.zip # 切换到 vim 源代码目录 cd vim-master/src # 配置 vim ./configure --with-features=huge \\ --enable-multibyte \\ --enable-rubyinterp=yes \\ --enable-pythoninterp=yes \\ --with-python-config-dir=/usr/lib/python2.7/config \\ --enable-python3interp=yes \\ --with-python3-config-dir=/usr/lib/python3.6/config \\ --enable-perlinterp=yes \\ --enable-luainterp=yes \\ --enable-gui=gtk2 \\ --enable-cscope \\ --prefix=/usr/local # 编译软件 make # 安装软件 sudo make install # 检查 vim 版本，应该是 9 vim --version 上面是源代码编译安装，或者使用 yum 安装 # 切换到 root 账户下 su rpm -Uvh http://mirror.ghettoforge.org/distributions/gf/gf-release-latest.gf.el7.noarch.rpm rpm --import http://mirror.ghettoforge.org/distributions/gf/RPM-GPG-KEY-gf.el7 yum -y remove vim-minimal vim-common vim-enhanced sudo yum -y --enablerepo=gf-plus install vim-enhanced sudo # 切换到 wangding 账户 exit # 检查 vim 版本，应该是 8 vim --version 安装 node.js sudo yum install -y gcc-c++ make curl --location https://rpm.nodesource.com/setup_10.x | sudo bash - sudo yum install -y nodejs # 检查 node.js 安装是否成功 node -v # 检查 npm 是否安装成功 npm -v 安装 zsh zsh 的安装过程如下： # 查看当前的 shell echo $SHELL # 安装 zsh sudo yum install -y zsh # 安装 wget sudo yum install -y wget # 安装 oh-my-zsh wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh # 却换 bash 至 zsh chsh -s /bin/zsh # 查新登录 shell exit # 连接 XShell，重新登录 Linux 检查命令行提示符变化 安装 vim 和 zsh 配置文件 安装完 vim 和 zsh 配置文件后，需要安装 zsh 插件。特别注意，安装 zsh 插件的过程不要中途退出，一定要等到出现命令行提示符再进行其他操作。 # 切换到 repos 目录 cd ~/repos # 克隆 wangding/tools 仓库 git clone https://github.com/wangding/tools # 安装配置文件 cd tools ./install.sh # 检查配置文件 ls -al ~ # .vimrc 文件应该存在 # .zshrc 文件应该存在 # 安装 zsh 插件，注意安装过程不要中途退出，一定要等到出现命令行提示符再进行其他操作 zsh # 退出当前 Shell exit # 连接 XShell，重新登录 Linux，zsh 的主题和插件都应该安装成功 安装 vim 插件管理工具 Vundle mkdir -p ~/.vim/bundle cd ~/.vim/bundle git clone https://github.com/VundleVim/Vundle.vim.git 安装 vim 插件 注意：安装 vim 插件的过程，不要中途退出，一定要等到所有插件都安装完成后，再进行其他操作。安装插件的过程如下图所示。 # 运行 vim 编辑器 vim # 安装 vim 插件 :PluginInstall # 退出 vim 插件安装 :q # 退出 vim :q 安装 tern_for_vim 的第三方依赖 # 切换到 tern_for_vim 目录 cd ~/.vim/bundle/tern_for_vim # 安装第三方依赖 npm Install 安装 YCM # 安装开发工具 sudo yum install -y automake gcc gcc-c++ kernel-devel cmake python-devel python3-devel # 切换到 YCM 目录 cd ~/.vim/bundle/YouCompleteMe # 安装 YCM ./install.py --tern-completer 安装开发辅助工具 su // 切换到 root 账户 yum install -y tree python-pygments // 安装 Linux 命令行 tree 工具和语法高亮工具 npm i -g htmlhint // 安装 HTMLHint 静态代码检查工具 npm i -g csslint // 安装 CSSLint 静态代码检查工具 npm i -g eslint // 安装 ESLint 静态代码检查工具 npm i -g browser-sync // 安装热加载工具 su wangding // 切换到开发者账户 检查开发辅助工具 tree /boot // 应该看到 boot 目录的树状结构 htmlhint --version // 应该看到版本号：0.9.13 或以上 csslint --version // 应该看到版本号：v1.0.4 或以上 eslint --version // 应该看到版本号：v4.17.0 或以上 browser-sync --version // 应该看到版本号：2.23.6 或以上 检查 vim 插件 验证 JavaScript 代码补全插件，操作步骤如下： cd mkdir test cd test touch .tern-project vim .tern-project .tern-project 文件的内容如下： { \"libs\": [\"browser\", \"jquery\"], \"plugins\": { \"node\": {} } } vim a.js i // 进入 vim 的插入模式 window. // 输入 window 然后按 . 看一下是否有 window 对象的属性、方法列出 Tab // 按键盘 tab 键，在 window 对象的属性、方法上切换 ( // 切换到 Date 按左括号 (，移动光标到行尾，输入分号 ; Enter X 2 // 按两次回车键 $. // 输入 $ 然后按 . 看一下是否有 JQuery $ 对象的属性、方法列出 // 如果没有自动补全的列表，删除 . 重新输入 . 再一两次 // 切换到 isArray 按左括号 (，移动光标到行尾，输入分号 ; Enter X 2 // 按两次回车键 process. // 输入 process 然后按 . 看一下是否有 process 对象的属性、方法列出 // 输入 ar，tab 键选择 argv，输入分号 ; :q! // 不保存退出 验证 emmet vim 插件，操作步骤如下： vim a.html // 命令行打开 vim 编辑器 i // 进入插入模式 !+y, // 输入感叹号，然后同时按 ctrl 和 y 键，然后按逗号键 // vim 窗口中应该出现 HTML5 的页面框架代码 :q! // 不保存退出 验证 jsdoc vim 插件，操作步骤如下： vim a.js // 命令行打开 vim 编辑器 i // 进入插入模式 // 写一个 x + y 的 add 加法函数，代码如下 function add(x, y) { return x + y; } ESC // 退出插入模式，进入普通模式，移动光标到第一行 :JsDoc // 按冒号进入命令模式，输入 JsDoc，注意命令大小写不要写错 // vim 窗口中应该出现函数头注释框架 :q! // 不保存退出 验证 CSS 代码补全功能，操作步骤如下： vim a.css // 命令行打开 vim 编辑器 i // 进入插入模式 // 写一个 body 的 CSS 样式代码，如下： body { background: // 注意在输入冒号和空格之后，应该弹出代码补全窗口 ESC // 回到普通模式 :q! // 不保存退出 2018 -  by 王顶. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/setup-dev-env.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/setup-dev-env.html\"});gitalk.render(\"gitalk-container\"); "},"mocha-dev-env.html":{"url":"mocha-dev-env.html","title":"升级开发环境","keywords":"","body":"升级开发环境 Mocha 虚拟机开发环境，可以完成 Node.js 后端开发。下面的安装步骤将使这个开发环境具备前端开发能力。另外，Node.js 后端开发环境也需要进行升级。 在确保自己的虚拟机能上网的前提下，执行以下搭建前端开发环境的步骤： 更新 tools 仓库 cd cd wd rm -rf tools git clone https://github.com/wangding/tools 安装 tools 仓库的 vim 配置文件 cd cd wd/tools cp .vimrc ~ 安装 vim 插件 注意：安装过程中，不要中途退出。一定要等 vim 提示 Done 后，才能退出。 vim // 命令行打开 vim 编辑器 :PluginInstall // vim 的普通模式下，按冒号进入命令模式 // 输入 PluginInstall 命令，注意命令的大小写 :q // vim 提示 Done 时，:q 退出安装界面 :q // 退出 vim 验证安装的 emmet vim 插件 vim a.html // 命令行打开 vim 编辑器 i // 进入插入模式 !+y, // 输入感叹号，然后同时按 ctrl 和 y 键，然后按逗号键 // vim 窗口中应该出现 HTML5 的页面框架代码 :q! // 不保存退出 验证安装的 jsdoc vim 插件 vim a.js // 命令行打开 vim 编辑器 i // 进入插入模式 // 写一个 x + y 的 add 加法函数，代码如下 function add(x, y) { return x + y; } ESC // 退出插入模式，进入普通模式，移动光标到第一行 :JsDoc // 按冒号进入命令模式，输入 JsDoc，注意命令大小写不要写错 // vim 窗口中应该出现函数头注释框架 :q! // 不保存退出 验证 CSS 代码补全功能 vim a.css // 命令行打开 vim 编辑器 i // 进入插入模式 // 写一个 body 的 CSS 样式代码，如下： body { background: // 注意在输入冒号和空格之后，应该弹出代码补全窗口 ESC // 回到普通模式 :q! // 不保存退出 验证代码注释工具 vi a.js // 命令行打开 vim 编辑器 i // 进入插入模式，接下来，写六行代码 var name = 'wangding', qq = '408542507', log = console.log; log(`name: ${name}`); log(`qq : ${qq}`); ESC // 回到普通模式 // 上下移动光标到任意一行代码 cc // 按空格和两个 c 键，对当前行注释 c // 按空格和 c 键以及空格键，取消当前行注释 V // 块选当前行 jj // 向下选中两行 cc // 对选中多行进行注释。取消注释，选中多行，按c 安装开发辅助工具 su // 切换到 root 账户 yum install -y tree // 安装 Linux 命令行 tree 工具和语法高亮工具 npm i -g htmlhint // 安装 HTMLHint 静态代码检查工具 npm i -g csslint // 安装 CSSLint 静态代码检查工具 npm i -g eslint // 安装 ESLint 静态代码检查工具 npm i -g browser-sync // 安装热加载工具 exit // 切换到开发者账户 wangding 验证 JavaScript 前端代码自动补全和后端代码补全 cd mkdir spa cd ~/spa wget http://sample.wangding.co/nodejs/tern-project mv tern-project .tern-project vim a.js // 命令行打开 vim 编辑器 i // 进入插入模式 window. // 输入 window 和点之后看到浏览器窗口对象 window 的方法提示 ESC // 回到普通模式 :q! // 不保存退出 vim a.js // 命令行打开 vim 编辑器 i // 进入插入模式 $. // 输入 $ 和点之后看到 jQuery 全局对象 $ 的方法提示 ESC // 回到普通模式 :q! // 不保存退出 vim a.js // 命令行打开 vim 编辑器 i // 进入插入模式 process. // 输入 process 和点之后看到 node.js 全局对象 process 的方法提示 ESC // 回到普通模式 :q! // 不保存退出 安装 nvm 并升级 node.js 版本 curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash 上面的安装步骤结束后，编辑 .zshrc 文件，执行命令：vi ~/.zshrc。在 zshrc 文件的最后增加下面两行代码： alias lrd=\"browser-sync start --server --port 8080 --no-open --files .\" alias pl=\"sudo firewall-cmd --zone=public --list-ports\" export NVM_DIR=\"$HOME/.nvm\" [ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\" # This loads nvm 保存 .zshrc 文件的修改，退出 vim。执行 linux bash 命令 exit 退出控制台，XShell 重新连接虚拟机。 升级 Node.js 版本到 10.16.3，执行下面的命令： node -v // 当前的 Node.js 版本应该是 6 nvm install 10 node -v // 升级后 Node.js 版本应该是 10 验证开发辅助工具 tree ~/wd // 应该看到 wd 目录的树状结构 htmlhint --version // 应该看到版本号不低于：0.9.13 csslint --version // 应该看到版本号不低于：v1.0.4 eslint --version // 应该看到版本号不低于：v4.17.0 browser-sync --version // 应该看到版本号不低于：2.23.6 掌握工具用法 Vim 代码编辑器 阅读 Vim 笔记 执行下列命令cd // 回到家目录 git clone https://github.com/wangding/jsnotepad tree jsnotepad // 查看 jsnotepad 项目下的代码文件 用 vim 打开 jsnotepad 项目中自己感兴趣的代码文件 html, css 或 js win 10 浏览器窗口（查看 vim 笔记）和 XShell 终端窗口平铺，左边是笔记，右边是终端窗口 对照左边文档，在终端窗口中练习 vim 的用法 Emmet 工具 安装 Emmet vim 插件，上面的开发环境搭建已经介绍过了 Emmet 工具在 vim 编辑器中的快捷键：+y, Emmet 语法，请参考：https://docs.emmet.io/abbreviations/syntax/ Emmet vim 插件用法，请参考：https://github.com/mattn/emmet-vim/blob/master/TUTORIAL 掌握 Emmet vim 常用的快捷键，+y，逗号，d，a，m，k，/，n 创建一个 emmet.html 文件，在 vim 中打开此文件，练习 Emmet 插件的用法 静态代码检查工具 安装静态代码检查工具，上面的开发环境搭建已经介绍过了 HTML 静态代码检查的规则，请参考：https://segmentfault.com/a/1190000013276858 CSS 静态代码检查的规则，请参考：https://github.com/CSSLint/csslint/wiki/Rules JavaScript 静态代码检查的规则，请参考：http://eslint.cn/docs/rules/ 创建 HTML、CSS 和 JavaScript 三个代码文件，在 vim 中编辑代码，体验静态代码检查插件的用法 热加载工具 安装热加载工具，上面的开发环境搭建已经介绍过了 执行如下操作，掌握热加载工具的用法： cd ~/spa // 进入前端页面所在的目录 lrd // 运行热加载程序，热加载程序会启动一个 Web 静态文件服务 // 在 XShell 另一个控制台窗口编写代码 vi index.html i // 进入插入模式 ! ctrl + y, // 产生 H5 页面框架代码 ESC // 从插入模式回到普通模式 w // 同时按下空格和 w 键，保存代码 打开 win10 的 chrome 浏览器 输入热加载程序提示的 URL 地址 chrome 浏览器中应该能看到刚才编写的页面代码 修改网页代码，保存，chrome 浏览器会自动刷新 通过热加载，浏览器能实时反映出页面的最新变化 不用手动刷新，提高开发效率 退出热加载按 Ctrl + C 2018 -  by 王顶. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/mocha-dev-env.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/mocha-dev-env.html\"});gitalk.render(\"gitalk-container\"); "},"env-manual.html":{"url":"env-manual.html","title":"开发环境使用","keywords":"","body":"开发环境使用 启动开发环境 操作步骤如下： 运行 vmware 虚拟机软件，打开 vmware 程序窗口 启动 mocha linux 虚拟机 打开 xshell 软件 连接到 mocha linux 虚拟机 在 xshell 中使用开发环境 关闭开发环境 操作步骤如下： 切换到 XShell 终端窗口 输入 sudo shutdown -h now 命令，关闭 linux 操作系统 XShell 的窗口为 DOS 命令行 在 DOS 命令行，输入 exit 命令，关闭 XShell 会话窗口 XShell 窗口关闭后，关闭 VMware 程序窗口 JavaScript 前端代码和后端代码自动补全 操作步骤如下： cd mkdir tmp cd tmp wget http://sample.wangding.co/nodejs/tern-project mv tern-project .tern-project vi a.js // 命令行打开 vim 编辑器 i // 进入插入模式 window. // 输入 window 和点之后看到浏览器窗口对象 window 的方法提示 ESC // 回到普通模式 :q! // 不保存退出 vi a.js // 命令行打开 vim 编辑器 i // 进入插入模式 console. // 输入 console 和点之后看到 node.js 全局对象 console 的方法提示 ESC // 回到普通模式 :q! // 不保存退出 JavaScript 代码注释工具 操作步骤如下： vi a.js // 命令行打开 vim 编辑器 i // 进入插入模式，接下来，写六行代码 var name = 'wangding', qq = '408542507', log = console.log; log(`name: ${name}`); log(`qq : ${qq}`); ESC // 回到普通模式 // 上下移动光标到任意一行代码 cc // 按空格和两个 c 键，对当前行注释 c // 按空格和 c 键以及空格键，取消当前行注释 V // 块选当前行 jj // 向下选中两行 cc // 对选中多行进行注释。取消注释，选中多行，按c 使用 jsdoc 插件，快速生成代码注释 操作步骤如下： vi a.js // 命令行打开 vim 编辑器 i // 进入插入模式 // 写一个 x + y 的 add 加法函数，代码如下 function add(x, y) { return x + y; } ESC // 退出插入模式，进入普通模式，移动光标到第一行 :JsDoc // 按冒号进入命令模式，输入 JsDoc，注意命令大小写不要写错 // vim 窗口中应该出现函数头注释框架 :q! // 不保存退出 使用 emmet 插件，快速编写 html 代码 操作步骤如下： vi a.html // 命令行打开 vim 编辑器 i // 进入插入模式 !+y, // 输入感叹号，然后同时按 ctrl 和 y 键，然后按逗号键 // vim 窗口中应该出现 HTML5 的页面框架代码 // 继续输入下面的代码 form>(label+input+br)*3+y, // 会生成一个登录表单的 DOM 代码框架 ESC // 回到 Normal 模式 :q! // 不保存退出 CSS 代码补全 操作步骤如下： vim a.css // 命令行打开 vim 编辑器 i // 进入插入模式 // 写一个 body 的 CSS 样式代码，如下： body { color: // 注意在输入冒号和空格之后，应该弹出代码补全窗口 ESC // 回到普通模式 :q! // 不保存退出 验证开发辅助工具 操作步骤如下： tree ~/wd // 应该看到 wd 目录的树状结构 htmlhint --version // 应该看到版本号不低于：0.9.13 csslint --version // 应该看到版本号不低于：v1.0.4 eslint --version // 应该看到版本号不低于：v4.17.0 browser-sync --version // 应该看到版本号不低于：2.23.6 gitbook --version // 应该看到 CLI 的版本号和 GitBook 的版本号 练习 vim 代码编辑器 阅读 Vim 笔记 执行下列命令cd // 回到家目录 git clone https://github.com/wangding/jsnotepad tree jsnotepad // 查看 jsnotepad 项目下的代码文件 用 vim 打开 jsnotepad 项目中自己感兴趣的代码文件 html, css 或 js win 10 浏览器窗口（查看 vim 笔记）和 XShell 终端窗口平铺，左边是笔记，右边是终端窗口 对照左边文档，在终端窗口中练习 vim 的用法 Emmet 工具的详细用法 Emmet 工具在 vim 编辑器中的快捷键：+y, Emmet 语法，请参考：https://docs.emmet.io/abbreviations/syntax/ Emmet vim 插件用法，请参考：https://github.com/mattn/emmet-vim/blob/master/TUTORIAL 掌握 Emmet vim 常用的快捷键，+y，逗号，d，a，m，k，/，n 创建一个 emmet.html 文件，在 vim 中打开此文件，练习 Emmet 插件的用法 静态代码检查工具的使用 HTML 静态代码检查的规则，请参考：https://segmentfault.com/a/1190000013276858 CSS 静态代码检查的规则，请参考：https://github.com/CSSLint/csslint/wiki/Rules JavaScript 静态代码检查的规则，请参考：http://eslint.cn/docs/rules/ 创建 HTML、CSS 和 JavaScript 三个代码文件，在 vim 中编辑代码，体验静态代码检查插件的用法 热加载工具的使用 执行如下操作，掌握热加载工具的用法： cd ~/spa // 进入前端页面所在的目录 lrd // 运行热加载程序，热加载程序会启动一个 Web 静态文件服务 // 在 XShell 另一个控制台窗口编写代码 vi index.html i // 进入插入模式 ! ctrl + y, // 产生 H5 页面框架代码 ESC // 从插入模式回到普通模式 w // 同时按下空格和 w 键，保存代码 打开 win10 的 chrome 浏览器 输入热加载程序提示的 URL 地址 chrome 浏览器中应该能看到刚才编写的页面代码 修改网页代码，保存，chrome 浏览器会自动刷新 通过热加载，浏览器能实时反映出页面的最新变化 不用手动刷新，提高开发效率 退出热加载按 Ctrl + C 2018 -  by 王顶. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/env-manual.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/env-manual.html\"});gitalk.render(\"gitalk-container\"); "},"video.html":{"url":"video.html","title":"视频清单","keywords":"","body":"课程视频清单 注意： 课程视频放在 B 站，登录 B 站后，课程视频可以高清观看 视频中的代码文字较小，最好在电脑上观看视频，不适合在手机上观看 开发环境使用 Git 使用 Vim 使用 Node.js 简介 开发环境搭建 课程说明 Node.js 简介 全局（上） 全局变量 使用全局变量 console 控制台 控制台输出 基准时间测试 process 进程 获取平台信息 使用命令行参数 程序退出码 标准 I/O 流操作 响应信号量 定时器 使用 setTimeout 延迟执行任务 使用定时器，定时执行任务 全局（下） Buffer 缓存 Buffer 基本用法 Base64 编码案例一：HTTP 基本身份验证 Base64 编码案例二：data URI 读取二进制位图文件 写入二进制位图文件 模块管理 使用全局模块 使用普通模块 使用第三方模块 自定义模块 加载一组相关模块 事件 编写事件响应函数 使用 EventEmitter 从 EventEmitter 原型继承 从 EventEmitter util 继承 混合 EventEmitter 管理异常 管理事件名称 流 标准输入输出流 HTTP 模块的请求和响应流 readable 推送流 readable 拉取流 自定义 readable 流 自定义 writable 流 文件系统 查看文件内容 复制文件和创建文件 移动文件和删除文件 目录操作 链接操作 属性操作 监视文件和目录 文件夹的递归操作 网络系统 创建 TCP 协议的服务端程序 创建 TCP 协议的客户端程序 创建 UDP 协议的服务端程序 创建 UDP 协议的客户端程序 创建 HTTP 协议的服务端程序 发起 HTTP GET 请求 请求一个 HTTP API 发起 HTTP POST 请求 执行 DNS 查询 处理 HTTP 重定向 HTTP 代理 子进程 子进程简介 execFile 方法执行外部程序 spawn 方法执行外部程序 exec 方法执行外部程序 分离子进程 fork 方法执行外部程序 同步执行外部程序 Web 应用 web 应用基础 HTTP 协议的基本验证 静态文件服务 从表单接收用户输入 创建 RESTful web 服务 前端代码访问 RESTful API 用 HTTPS 加强程序的安全性 测试 用 assert 模块编写测试脚本 调试 调试简介 JSHint 静态代码检查 使用 Node.js 命令行调试器 使用 Chrome 开发者工具调试 性能分析 数据存储 内存存储 文件存储 mongodb 存储 压缩与解压缩 文件压缩与解压缩 对 HTTP 数据压缩 通过 HTTP Proxy 查看 HTTP 数据压缩 JavaScript 异步编程 JavaScript 异步编程概述 JavaScript 异步并发操作 回调函数的异步流程控制 Promise 的异步流程控制 await 的异步流程控制 回调异步流程控制的数据传递 Promise 异步流程控制的数据传递 await 异步流程控制的数据传递 HTTP 编程概述 HTTP 协议概述 HTTP 客户端程序 爬虫概述 简单爬虫的实现 复杂爬虫的实现 HTTP 服务端程序 后台模板渲染架构 前后端分离架构 Koa2 快速上手 第一个 koa web 服务 中间件 中间件是什么 中间件的操作流程和数据传递 中间件的异步操作和洋葱模型 路由 koa 原生路由 koa-router 路由和请求参数获取 路由模块化和路由模块管理 常用的 Web 编程技术 数据库访问 数据存储概述 数据库的基本概念 MySQL 的安装与 Shell 操作 Workbench 的安装和使用 SQL 编程（上） SQL 编程（中） SQL 编程（下） HTTP 接口服务 HTTP 接口服务概述 mysql2 API 操作数据库（上） mysql2 API 操作数据库（下） Sequelize ORM ORM 概述 Sequelize 执行简单查询 Sequelize 执行高级查询（上） Sequelize 执行高级查询（下） JWT 身份验证 JWT 概述 对接口服务实现 JWT 身份验证（上） 对接口服务实现 JWT 身份验证（下） 2018 -  by 王顶. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/video.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/video.html\"});gitalk.render(\"gitalk-container\"); "},"test.html":{"url":"test.html","title":"课堂测验","keywords":"","body":"Node.js 应用开发课堂测验 第一课：Node.js 简介 第二课：全局（上） 第三课：全局（下） 第四课：事件 第五课：流 第六课：文件系统 第七课：调试 第八课：子进程 第九课：网络 第十课：HTTP 客户端 第十课：HTTP 服务端 第十一课：HTTP 进阶 第十二课：数据存储 第十三课：koa 框架 2018 -  by 王顶. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); window.onload = function() {gitbook.events.on(\"page.change\", function() {var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/test.html\"});gitalk.render(\"gitalk-container\");});};var gitalk = new Gitalk({\"clientID\":\"082a682f79b163ab6198\",\"clientSecret\":\"f872143a272619b840ea2a1838f1316aa38ba994\",\"repo\":\"nodejs\",\"owner\":\"wangding\",\"admin\":[\"wangding\"],\"labels\":[\"nodejs\"],\"id\":\"/test.html\"});gitalk.render(\"gitalk-container\"); "}}